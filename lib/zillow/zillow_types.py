#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Sat Oct 10 13:40:29 2015 by generateDS.py version 2.17a.
#
# Command line options:
#   ('-o', 'zillow_types.py')
#
# Command line arguments:
#   ZillowTypes.xsd
#
# Command line:
#   /usr/local/bin/generateDS.py -o "zillow_types.py" ZillowTypes.xsd
#
# Current working directory (os.getcwd()):
#   www
#

# Python Standard Library Imports
import datetime as datetime_
import re as re_
import sys
import warnings as warnings_

# Third Party (PyPI) Imports
from lxml import etree as etree_

# HTK Imports
from htk.compat import b64encode


try:
    basestring
except NameError:
    basestring = str


Validate_simpletypes_ = True


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        parser = etree_.ETCompatXMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data

        def gds_format_base64(self, input_data, input_name=''):
            value = b64encode(input_data)
            return value

        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            value = b64encode(self.value)
            outfile.write('<%s>%s</%s>' % (self.name, value, self.name))

    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class Amount(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, currency=None, valueOf_=None):
        self.original_tagname_ = None
        self.currency = _cast(None, currency)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Amount.subclass:
            return Amount.subclass(*args_, **kwargs_)
        else:
            return Amount(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='Amount', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Amount')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='Amount', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='Amount'):
        if self.currency is not None and 'currency' not in already_processed:
            already_processed.add('currency')
            outfile.write(' currency=%s' % (quote_attrib(self.currency), ))
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='Amount', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('currency', node)
        if value is not None and 'currency' not in already_processed:
            already_processed.add('currency')
            self.currency = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Amount


class Address(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, street=None, zipcode=None, city=None, state=None, latitude=None, longitude=None):
        self.original_tagname_ = None
        self.street = street
        self.zipcode = zipcode
        self.city = city
        self.state = state
        self.latitude = latitude
        self.longitude = longitude
    def factory(*args_, **kwargs_):
        if Address.subclass:
            return Address.subclass(*args_, **kwargs_)
        else:
            return Address(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_street(self): return self.street
    def set_street(self, street): self.street = street
    def get_zipcode(self): return self.zipcode
    def set_zipcode(self, zipcode): self.zipcode = zipcode
    def get_city(self): return self.city
    def set_city(self, city): self.city = city
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def get_latitude(self): return self.latitude
    def set_latitude(self, latitude): self.latitude = latitude
    def get_longitude(self): return self.longitude
    def set_longitude(self, longitude): self.longitude = longitude
    def hasContent_(self):
        if (
            self.street is not None or
            self.zipcode is not None or
            self.city is not None or
            self.state is not None or
            self.latitude is not None or
            self.longitude is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='Address', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Address')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='Address', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='Address'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='Address', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.street is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstreet>%s</%sstreet>%s' % (namespace_, self.gds_format_string(quote_xml(self.street).encode(ExternalEncoding), input_name='street'), namespace_, eol_))
        if self.zipcode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%szipcode>%s</%szipcode>%s' % (namespace_, self.gds_format_string(quote_xml(self.zipcode).encode(ExternalEncoding), input_name='zipcode'), namespace_, eol_))
        if self.city is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scity>%s</%scity>%s' % (namespace_, self.gds_format_string(quote_xml(self.city).encode(ExternalEncoding), input_name='city'), namespace_, eol_))
        if self.state is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstate>%s</%sstate>%s' % (namespace_, self.gds_format_string(quote_xml(self.state).encode(ExternalEncoding), input_name='state'), namespace_, eol_))
        if self.latitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slatitude>%s</%slatitude>%s' % (namespace_, self.gds_format_float(self.latitude, input_name='latitude'), namespace_, eol_))
        if self.longitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slongitude>%s</%slongitude>%s' % (namespace_, self.gds_format_float(self.longitude, input_name='longitude'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'street':
            street_ = child_.text
            street_ = self.gds_validate_string(street_, node, 'street')
            self.street = street_
        elif nodeName_ == 'zipcode':
            zipcode_ = child_.text
            zipcode_ = self.gds_validate_string(zipcode_, node, 'zipcode')
            self.zipcode = zipcode_
        elif nodeName_ == 'city':
            city_ = child_.text
            city_ = self.gds_validate_string(city_, node, 'city')
            self.city = city_
        elif nodeName_ == 'state':
            state_ = child_.text
            state_ = self.gds_validate_string(state_, node, 'state')
            self.state = state_
        elif nodeName_ == 'latitude':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'latitude')
            self.latitude = fval_
        elif nodeName_ == 'longitude':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'longitude')
            self.longitude = fval_
# end class Address


class RestrictedAddress(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, street=None, zipcode=None, city=None, state=None, latitude=None, longitude=None):
        self.original_tagname_ = None
        self.street = street
        self.zipcode = zipcode
        self.city = city
        self.state = state
        self.latitude = latitude
        self.longitude = longitude
    def factory(*args_, **kwargs_):
        if RestrictedAddress.subclass:
            return RestrictedAddress.subclass(*args_, **kwargs_)
        else:
            return RestrictedAddress(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_street(self): return self.street
    def set_street(self, street): self.street = street
    def get_zipcode(self): return self.zipcode
    def set_zipcode(self, zipcode): self.zipcode = zipcode
    def get_city(self): return self.city
    def set_city(self, city): self.city = city
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def get_latitude(self): return self.latitude
    def set_latitude(self, latitude): self.latitude = latitude
    def get_longitude(self): return self.longitude
    def set_longitude(self, longitude): self.longitude = longitude
    def hasContent_(self):
        if (
            self.street is not None or
            self.zipcode is not None or
            self.city is not None or
            self.state is not None or
            self.latitude is not None or
            self.longitude is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='RestrictedAddress', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RestrictedAddress')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='RestrictedAddress', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='RestrictedAddress'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='RestrictedAddress', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.street is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstreet>%s</%sstreet>%s' % (namespace_, self.gds_format_string(quote_xml(self.street).encode(ExternalEncoding), input_name='street'), namespace_, eol_))
        if self.zipcode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%szipcode>%s</%szipcode>%s' % (namespace_, self.gds_format_string(quote_xml(self.zipcode).encode(ExternalEncoding), input_name='zipcode'), namespace_, eol_))
        if self.city is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scity>%s</%scity>%s' % (namespace_, self.gds_format_string(quote_xml(self.city).encode(ExternalEncoding), input_name='city'), namespace_, eol_))
        if self.state is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstate>%s</%sstate>%s' % (namespace_, self.gds_format_string(quote_xml(self.state).encode(ExternalEncoding), input_name='state'), namespace_, eol_))
        if self.latitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slatitude>%s</%slatitude>%s' % (namespace_, self.gds_format_float(self.latitude, input_name='latitude'), namespace_, eol_))
        if self.longitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slongitude>%s</%slongitude>%s' % (namespace_, self.gds_format_float(self.longitude, input_name='longitude'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'street':
            street_ = child_.text
            street_ = self.gds_validate_string(street_, node, 'street')
            self.street = street_
        elif nodeName_ == 'zipcode':
            zipcode_ = child_.text
            zipcode_ = self.gds_validate_string(zipcode_, node, 'zipcode')
            self.zipcode = zipcode_
        elif nodeName_ == 'city':
            city_ = child_.text
            city_ = self.gds_validate_string(city_, node, 'city')
            self.city = city_
        elif nodeName_ == 'state':
            state_ = child_.text
            state_ = self.gds_validate_string(state_, node, 'state')
            self.state = state_
        elif nodeName_ == 'latitude':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'latitude')
            self.latitude = fval_
        elif nodeName_ == 'longitude':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'longitude')
            self.longitude = fval_
# end class RestrictedAddress


class Message(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, text=None, code=None, limit_warning=None):
        self.original_tagname_ = None
        self.text = text
        self.code = code
        self.limit_warning = limit_warning
    def factory(*args_, **kwargs_):
        if Message.subclass:
            return Message.subclass(*args_, **kwargs_)
        else:
            return Message(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_text(self): return self.text
    def set_text(self, text): self.text = text
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_limit_warning(self): return self.limit_warning
    def set_limit_warning(self, limit_warning): self.limit_warning = limit_warning
    def hasContent_(self):
        if (
            self.text is not None or
            self.code is not None or
            self.limit_warning is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='Message', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Message')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='Message', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='Message'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='Message', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.text is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stext>%s</%stext>%s' % (namespace_, self.gds_format_string(quote_xml(self.text).encode(ExternalEncoding), input_name='text'), namespace_, eol_))
        if self.code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scode>%s</%scode>%s' % (namespace_, self.gds_format_integer(self.code, input_name='code'), namespace_, eol_))
        if self.limit_warning is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slimit-warning>%s</%slimit-warning>%s' % (namespace_, self.gds_format_boolean(self.limit_warning, input_name='limit-warning'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'text':
            text_ = child_.text
            text_ = self.gds_validate_string(text_, node, 'text')
            self.text = text_
        elif nodeName_ == 'code':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'code')
            self.code = ival_
        elif nodeName_ == 'limit-warning':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'limit_warning')
            self.limit_warning = ival_
# end class Message


class Regions(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, zipcode_id=None, city_id=None, county_id=None, state_id=None):
        self.original_tagname_ = None
        self.zipcode_id = zipcode_id
        self.city_id = city_id
        self.county_id = county_id
        self.state_id = state_id
    def factory(*args_, **kwargs_):
        if Regions.subclass:
            return Regions.subclass(*args_, **kwargs_)
        else:
            return Regions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_zipcode_id(self): return self.zipcode_id
    def set_zipcode_id(self, zipcode_id): self.zipcode_id = zipcode_id
    def get_city_id(self): return self.city_id
    def set_city_id(self, city_id): self.city_id = city_id
    def get_county_id(self): return self.county_id
    def set_county_id(self, county_id): self.county_id = county_id
    def get_state_id(self): return self.state_id
    def set_state_id(self, state_id): self.state_id = state_id
    def hasContent_(self):
        if (
            self.zipcode_id is not None or
            self.city_id is not None or
            self.county_id is not None or
            self.state_id is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='Regions', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Regions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='Regions', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='Regions'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='Regions', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.zipcode_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%szipcode-id>%s</%szipcode-id>%s' % (namespace_, self.gds_format_integer(self.zipcode_id, input_name='zipcode-id'), namespace_, eol_))
        if self.city_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scity-id>%s</%scity-id>%s' % (namespace_, self.gds_format_integer(self.city_id, input_name='city-id'), namespace_, eol_))
        if self.county_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scounty-id>%s</%scounty-id>%s' % (namespace_, self.gds_format_integer(self.county_id, input_name='county-id'), namespace_, eol_))
        if self.state_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstate-id>%s</%sstate-id>%s' % (namespace_, self.gds_format_integer(self.state_id, input_name='state-id'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'zipcode-id':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'zipcode_id')
            self.zipcode_id = ival_
        elif nodeName_ == 'city-id':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'city_id')
            self.city_id = ival_
        elif nodeName_ == 'county-id':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'county_id')
            self.county_id = ival_
        elif nodeName_ == 'state-id':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'state_id')
            self.state_id = ival_
# end class Regions


class RegionNames(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, country=None, state=None, county=None, city=None, cityurl=None, zipcode=None, neighborhood=None, neighborhoodurl=None, latitude=None, longitude=None):
        self.original_tagname_ = None
        self.id = id
        self.country = country
        self.state = state
        self.county = county
        self.city = city
        self.cityurl = cityurl
        self.zipcode = zipcode
        self.neighborhood = neighborhood
        self.neighborhoodurl = neighborhoodurl
        self.latitude = latitude
        self.longitude = longitude
    def factory(*args_, **kwargs_):
        if RegionNames.subclass:
            return RegionNames.subclass(*args_, **kwargs_)
        else:
            return RegionNames(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_country(self): return self.country
    def set_country(self, country): self.country = country
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def get_county(self): return self.county
    def set_county(self, county): self.county = county
    def get_city(self): return self.city
    def set_city(self, city): self.city = city
    def get_cityurl(self): return self.cityurl
    def set_cityurl(self, cityurl): self.cityurl = cityurl
    def get_zipcode(self): return self.zipcode
    def set_zipcode(self, zipcode): self.zipcode = zipcode
    def get_neighborhood(self): return self.neighborhood
    def set_neighborhood(self, neighborhood): self.neighborhood = neighborhood
    def get_neighborhoodurl(self): return self.neighborhoodurl
    def set_neighborhoodurl(self, neighborhoodurl): self.neighborhoodurl = neighborhoodurl
    def get_latitude(self): return self.latitude
    def set_latitude(self, latitude): self.latitude = latitude
    def get_longitude(self): return self.longitude
    def set_longitude(self, longitude): self.longitude = longitude
    def hasContent_(self):
        if (
            self.id is not None or
            self.country is not None or
            self.state is not None or
            self.county is not None or
            self.city is not None or
            self.cityurl is not None or
            self.zipcode is not None or
            self.neighborhood is not None or
            self.neighborhoodurl is not None or
            self.latitude is not None or
            self.longitude is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='RegionNames', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RegionNames')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='RegionNames', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='RegionNames'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='RegionNames', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespace_, self.gds_format_string(quote_xml(self.id).encode(ExternalEncoding), input_name='id'), namespace_, eol_))
        if self.country is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scountry>%s</%scountry>%s' % (namespace_, self.gds_format_string(quote_xml(self.country).encode(ExternalEncoding), input_name='country'), namespace_, eol_))
        if self.state is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstate>%s</%sstate>%s' % (namespace_, self.gds_format_string(quote_xml(self.state).encode(ExternalEncoding), input_name='state'), namespace_, eol_))
        if self.county is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scounty>%s</%scounty>%s' % (namespace_, self.gds_format_string(quote_xml(self.county).encode(ExternalEncoding), input_name='county'), namespace_, eol_))
        if self.city is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scity>%s</%scity>%s' % (namespace_, self.gds_format_string(quote_xml(self.city).encode(ExternalEncoding), input_name='city'), namespace_, eol_))
        if self.cityurl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scityurl>%s</%scityurl>%s' % (namespace_, self.gds_format_string(quote_xml(self.cityurl).encode(ExternalEncoding), input_name='cityurl'), namespace_, eol_))
        if self.zipcode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%szipcode>%s</%szipcode>%s' % (namespace_, self.gds_format_string(quote_xml(self.zipcode).encode(ExternalEncoding), input_name='zipcode'), namespace_, eol_))
        if self.neighborhood is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sneighborhood>%s</%sneighborhood>%s' % (namespace_, self.gds_format_string(quote_xml(self.neighborhood).encode(ExternalEncoding), input_name='neighborhood'), namespace_, eol_))
        if self.neighborhoodurl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sneighborhoodurl>%s</%sneighborhoodurl>%s' % (namespace_, self.gds_format_string(quote_xml(self.neighborhoodurl).encode(ExternalEncoding), input_name='neighborhoodurl'), namespace_, eol_))
        if self.latitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slatitude>%s</%slatitude>%s' % (namespace_, self.gds_format_float(self.latitude, input_name='latitude'), namespace_, eol_))
        if self.longitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slongitude>%s</%slongitude>%s' % (namespace_, self.gds_format_float(self.longitude, input_name='longitude'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'id':
            id_ = child_.text
            id_ = self.gds_validate_string(id_, node, 'id')
            self.id = id_
        elif nodeName_ == 'country':
            country_ = child_.text
            country_ = self.gds_validate_string(country_, node, 'country')
            self.country = country_
        elif nodeName_ == 'state':
            state_ = child_.text
            state_ = self.gds_validate_string(state_, node, 'state')
            self.state = state_
        elif nodeName_ == 'county':
            county_ = child_.text
            county_ = self.gds_validate_string(county_, node, 'county')
            self.county = county_
        elif nodeName_ == 'city':
            city_ = child_.text
            city_ = self.gds_validate_string(city_, node, 'city')
            self.city = city_
        elif nodeName_ == 'cityurl':
            cityurl_ = child_.text
            cityurl_ = self.gds_validate_string(cityurl_, node, 'cityurl')
            self.cityurl = cityurl_
        elif nodeName_ == 'zipcode':
            zipcode_ = child_.text
            zipcode_ = self.gds_validate_string(zipcode_, node, 'zipcode')
            self.zipcode = zipcode_
        elif nodeName_ == 'neighborhood':
            neighborhood_ = child_.text
            neighborhood_ = self.gds_validate_string(neighborhood_, node, 'neighborhood')
            self.neighborhood = neighborhood_
        elif nodeName_ == 'neighborhoodurl':
            neighborhoodurl_ = child_.text
            neighborhoodurl_ = self.gds_validate_string(neighborhoodurl_, node, 'neighborhoodurl')
            self.neighborhoodurl = neighborhoodurl_
        elif nodeName_ == 'latitude':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'latitude')
            self.latitude = fval_
        elif nodeName_ == 'longitude':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'longitude')
            self.longitude = fval_
# end class RegionNames


class Zestimate(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, amount=None, last_updated=None, oneWeekChange=None, valueChange=None, valuationRange=None, percentile=None):
        self.original_tagname_ = None
        self.amount = amount
        self.last_updated = last_updated
        self.oneWeekChange = oneWeekChange
        self.valueChange = valueChange
        self.valuationRange = valuationRange
        self.percentile = percentile
    def factory(*args_, **kwargs_):
        if Zestimate.subclass:
            return Zestimate.subclass(*args_, **kwargs_)
        else:
            return Zestimate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_amount(self): return self.amount
    def set_amount(self, amount): self.amount = amount
    def get_last_updated(self): return self.last_updated
    def set_last_updated(self, last_updated): self.last_updated = last_updated
    def get_oneWeekChange(self): return self.oneWeekChange
    def set_oneWeekChange(self, oneWeekChange): self.oneWeekChange = oneWeekChange
    def get_valueChange(self): return self.valueChange
    def set_valueChange(self, valueChange): self.valueChange = valueChange
    def get_valuationRange(self): return self.valuationRange
    def set_valuationRange(self, valuationRange): self.valuationRange = valuationRange
    def get_percentile(self): return self.percentile
    def set_percentile(self, percentile): self.percentile = percentile
    def hasContent_(self):
        if (
            self.amount is not None or
            self.last_updated is not None or
            self.oneWeekChange is not None or
            self.valueChange is not None or
            self.valuationRange is not None or
            self.percentile is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='Zestimate', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Zestimate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='Zestimate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='Zestimate'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='Zestimate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.amount is not None:
            self.amount.export(outfile, level, namespace_, name_='amount', pretty_print=pretty_print)
        if self.last_updated is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slast-updated>%s</%slast-updated>%s' % (namespace_, self.gds_format_string(quote_xml(self.last_updated).encode(ExternalEncoding), input_name='last-updated'), namespace_, eol_))
        if self.oneWeekChange is not None:
            self.oneWeekChange.export(outfile, level, namespace_, name_='oneWeekChange', pretty_print=pretty_print)
        if self.valueChange is not None:
            self.valueChange.export(outfile, level, namespace_, name_='valueChange', pretty_print=pretty_print)
        if self.valuationRange is not None:
            self.valuationRange.export(outfile, level, namespace_, name_='valuationRange', pretty_print=pretty_print)
        if self.percentile is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spercentile>%s</%spercentile>%s' % (namespace_, self.gds_format_string(quote_xml(self.percentile).encode(ExternalEncoding), input_name='percentile'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'amount':
            obj_ = Amount.factory()
            obj_.build(child_)
            self.amount = obj_
            obj_.original_tagname_ = 'amount'
        elif nodeName_ == 'last-updated':
            last_updated_ = child_.text
            last_updated_ = self.gds_validate_string(last_updated_, node, 'last_updated')
            self.last_updated = last_updated_
        elif nodeName_ == 'oneWeekChange':
            obj_ = AmountOptional.factory()
            obj_.build(child_)
            self.oneWeekChange = obj_
            obj_.original_tagname_ = 'oneWeekChange'
        elif nodeName_ == 'valueChange':
            obj_ = AmountOptional.factory()
            obj_.build(child_)
            self.valueChange = obj_
            obj_.original_tagname_ = 'valueChange'
        elif nodeName_ == 'valuationRange':
            obj_ = valuationRangeType.factory()
            obj_.build(child_)
            self.valuationRange = obj_
            obj_.original_tagname_ = 'valuationRange'
        elif nodeName_ == 'percentile':
            percentile_ = child_.text
            percentile_ = self.gds_validate_string(percentile_, node, 'percentile')
            self.percentile = percentile_
# end class Zestimate


class SimpleZestimate(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, amount=None, valuationRange=None):
        self.original_tagname_ = None
        self.amount = amount
        self.valuationRange = valuationRange
    def factory(*args_, **kwargs_):
        if SimpleZestimate.subclass:
            return SimpleZestimate.subclass(*args_, **kwargs_)
        else:
            return SimpleZestimate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_amount(self): return self.amount
    def set_amount(self, amount): self.amount = amount
    def get_valuationRange(self): return self.valuationRange
    def set_valuationRange(self, valuationRange): self.valuationRange = valuationRange
    def hasContent_(self):
        if (
            self.amount is not None or
            self.valuationRange is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='SimpleZestimate', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SimpleZestimate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='SimpleZestimate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='SimpleZestimate'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='SimpleZestimate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.amount is not None:
            self.amount.export(outfile, level, namespace_, name_='amount', pretty_print=pretty_print)
        if self.valuationRange is not None:
            self.valuationRange.export(outfile, level, namespace_, name_='valuationRange', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'amount':
            obj_ = Amount.factory()
            obj_.build(child_)
            self.amount = obj_
            obj_.original_tagname_ = 'amount'
        elif nodeName_ == 'valuationRange':
            obj_ = valuationRangeType1.factory()
            obj_.build(child_)
            self.valuationRange = obj_
            obj_.original_tagname_ = 'valuationRange'
# end class SimpleZestimate


class LocalRealEstate(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, region=None):
        self.original_tagname_ = None
        if region is None:
            self.region = []
        else:
            self.region = region
    def factory(*args_, **kwargs_):
        if LocalRealEstate.subclass:
            return LocalRealEstate.subclass(*args_, **kwargs_)
        else:
            return LocalRealEstate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_region(self): return self.region
    def set_region(self, region): self.region = region
    def add_region(self, value): self.region.append(value)
    def insert_region_at(self, index, value): self.region.insert(index, value)
    def replace_region_at(self, index, value): self.region[index] = value
    def hasContent_(self):
        if (
            self.region
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='LocalRealEstate', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocalRealEstate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='LocalRealEstate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='LocalRealEstate'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='LocalRealEstate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for region_ in self.region:
            region_.export(outfile, level, namespace_, name_='region', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'region':
            obj_ = regionType.factory()
            obj_.build(child_)
            self.region.append(obj_)
            obj_.original_tagname_ = 'region'
# end class LocalRealEstate


class Links(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, homedetails=None, graphsanddata=None, mapthishome=None, myestimator=None, myzestimator=None, comparables=None):
        self.original_tagname_ = None
        self.homedetails = homedetails
        self.graphsanddata = graphsanddata
        self.mapthishome = mapthishome
        self.myestimator = myestimator
        self.myzestimator = myzestimator
        self.comparables = comparables
    def factory(*args_, **kwargs_):
        if Links.subclass:
            return Links.subclass(*args_, **kwargs_)
        else:
            return Links(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_homedetails(self): return self.homedetails
    def set_homedetails(self, homedetails): self.homedetails = homedetails
    def get_graphsanddata(self): return self.graphsanddata
    def set_graphsanddata(self, graphsanddata): self.graphsanddata = graphsanddata
    def get_mapthishome(self): return self.mapthishome
    def set_mapthishome(self, mapthishome): self.mapthishome = mapthishome
    def get_myestimator(self): return self.myestimator
    def set_myestimator(self, myestimator): self.myestimator = myestimator
    def get_myzestimator(self): return self.myzestimator
    def set_myzestimator(self, myzestimator): self.myzestimator = myzestimator
    def get_comparables(self): return self.comparables
    def set_comparables(self, comparables): self.comparables = comparables
    def hasContent_(self):
        if (
            self.homedetails is not None or
            self.graphsanddata is not None or
            self.mapthishome is not None or
            self.myestimator is not None or
            self.myzestimator is not None or
            self.comparables is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='Links', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Links')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='Links', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='Links'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='Links', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.homedetails is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shomedetails>%s</%shomedetails>%s' % (namespace_, self.gds_format_string(quote_xml(self.homedetails).encode(ExternalEncoding), input_name='homedetails'), namespace_, eol_))
        if self.graphsanddata is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgraphsanddata>%s</%sgraphsanddata>%s' % (namespace_, self.gds_format_string(quote_xml(self.graphsanddata).encode(ExternalEncoding), input_name='graphsanddata'), namespace_, eol_))
        if self.mapthishome is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smapthishome>%s</%smapthishome>%s' % (namespace_, self.gds_format_string(quote_xml(self.mapthishome).encode(ExternalEncoding), input_name='mapthishome'), namespace_, eol_))
        if self.myestimator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smyestimator>%s</%smyestimator>%s' % (namespace_, self.gds_format_string(quote_xml(self.myestimator).encode(ExternalEncoding), input_name='myestimator'), namespace_, eol_))
        if self.myzestimator is not None:
            self.myzestimator.export(outfile, level, namespace_, name_='myzestimator', pretty_print=pretty_print)
        if self.comparables is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomparables>%s</%scomparables>%s' % (namespace_, self.gds_format_string(quote_xml(self.comparables).encode(ExternalEncoding), input_name='comparables'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'homedetails':
            homedetails_ = child_.text
            homedetails_ = self.gds_validate_string(homedetails_, node, 'homedetails')
            self.homedetails = homedetails_
        elif nodeName_ == 'graphsanddata':
            graphsanddata_ = child_.text
            graphsanddata_ = self.gds_validate_string(graphsanddata_, node, 'graphsanddata')
            self.graphsanddata = graphsanddata_
        elif nodeName_ == 'mapthishome':
            mapthishome_ = child_.text
            mapthishome_ = self.gds_validate_string(mapthishome_, node, 'mapthishome')
            self.mapthishome = mapthishome_
        elif nodeName_ == 'myestimator':
            myestimator_ = child_.text
            myestimator_ = self.gds_validate_string(myestimator_, node, 'myestimator')
            self.myestimator = myestimator_
        elif nodeName_ == 'myzestimator':
            obj_ = DeprecatedType.factory()
            obj_.build(child_)
            self.myzestimator = obj_
            obj_.original_tagname_ = 'myzestimator'
        elif nodeName_ == 'comparables':
            comparables_ = child_.text
            comparables_ = self.gds_validate_string(comparables_, node, 'comparables')
            self.comparables = comparables_
# end class Links


class Property(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, zpid=None, links=None, address=None, FIPScounty=None, useCode=None, taxAssessmentYear=None, taxAssessment=None, yearBuilt=None, lotSizeSqFt=None, finishedSqFt=None, bathrooms=None, bedrooms=None, totalRooms=None, lastSoldDate=None, lastSoldPrice=None, extensiontype_=None):
        self.original_tagname_ = None
        self.zpid = zpid
        self.links = links
        self.address = address
        self.FIPScounty = FIPScounty
        self.useCode = useCode
        self.taxAssessmentYear = taxAssessmentYear
        self.taxAssessment = taxAssessment
        self.yearBuilt = yearBuilt
        self.lotSizeSqFt = lotSizeSqFt
        self.finishedSqFt = finishedSqFt
        self.bathrooms = bathrooms
        self.bedrooms = bedrooms
        self.totalRooms = totalRooms
        self.lastSoldDate = lastSoldDate
        self.lastSoldPrice = lastSoldPrice
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if Property.subclass:
            return Property.subclass(*args_, **kwargs_)
        else:
            return Property(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_zpid(self): return self.zpid
    def set_zpid(self, zpid): self.zpid = zpid
    def get_links(self): return self.links
    def set_links(self, links): self.links = links
    def get_address(self): return self.address
    def set_address(self, address): self.address = address
    def get_FIPScounty(self): return self.FIPScounty
    def set_FIPScounty(self, FIPScounty): self.FIPScounty = FIPScounty
    def get_useCode(self): return self.useCode
    def set_useCode(self, useCode): self.useCode = useCode
    def get_taxAssessmentYear(self): return self.taxAssessmentYear
    def set_taxAssessmentYear(self, taxAssessmentYear): self.taxAssessmentYear = taxAssessmentYear
    def get_taxAssessment(self): return self.taxAssessment
    def set_taxAssessment(self, taxAssessment): self.taxAssessment = taxAssessment
    def get_yearBuilt(self): return self.yearBuilt
    def set_yearBuilt(self, yearBuilt): self.yearBuilt = yearBuilt
    def get_lotSizeSqFt(self): return self.lotSizeSqFt
    def set_lotSizeSqFt(self, lotSizeSqFt): self.lotSizeSqFt = lotSizeSqFt
    def get_finishedSqFt(self): return self.finishedSqFt
    def set_finishedSqFt(self, finishedSqFt): self.finishedSqFt = finishedSqFt
    def get_bathrooms(self): return self.bathrooms
    def set_bathrooms(self, bathrooms): self.bathrooms = bathrooms
    def get_bedrooms(self): return self.bedrooms
    def set_bedrooms(self, bedrooms): self.bedrooms = bedrooms
    def get_totalRooms(self): return self.totalRooms
    def set_totalRooms(self, totalRooms): self.totalRooms = totalRooms
    def get_lastSoldDate(self): return self.lastSoldDate
    def set_lastSoldDate(self, lastSoldDate): self.lastSoldDate = lastSoldDate
    def get_lastSoldPrice(self): return self.lastSoldPrice
    def set_lastSoldPrice(self, lastSoldPrice): self.lastSoldPrice = lastSoldPrice
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.zpid is not None or
            self.links is not None or
            self.address is not None or
            self.FIPScounty is not None or
            self.useCode is not None or
            self.taxAssessmentYear is not None or
            self.taxAssessment is not None or
            self.yearBuilt is not None or
            self.lotSizeSqFt is not None or
            self.finishedSqFt is not None or
            self.bathrooms is not None or
            self.bedrooms is not None or
            self.totalRooms is not None or
            self.lastSoldDate is not None or
            self.lastSoldPrice is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='Property', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Property')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='Property', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='Property'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='Property', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.zpid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%szpid>%s</%szpid>%s' % (namespace_, self.gds_format_integer(self.zpid, input_name='zpid'), namespace_, eol_))
        if self.links is not None:
            self.links.export(outfile, level, namespace_, name_='links', pretty_print=pretty_print)
        if self.address is not None:
            self.address.export(outfile, level, namespace_, name_='address', pretty_print=pretty_print)
        if self.FIPScounty is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFIPScounty>%s</%sFIPScounty>%s' % (namespace_, self.gds_format_string(quote_xml(self.FIPScounty).encode(ExternalEncoding), input_name='FIPScounty'), namespace_, eol_))
        if self.useCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suseCode>%s</%suseCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.useCode).encode(ExternalEncoding), input_name='useCode'), namespace_, eol_))
        if self.taxAssessmentYear is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%staxAssessmentYear>%s</%staxAssessmentYear>%s' % (namespace_, self.gds_format_string(quote_xml(self.taxAssessmentYear).encode(ExternalEncoding), input_name='taxAssessmentYear'), namespace_, eol_))
        if self.taxAssessment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%staxAssessment>%s</%staxAssessment>%s' % (namespace_, self.gds_format_string(quote_xml(self.taxAssessment).encode(ExternalEncoding), input_name='taxAssessment'), namespace_, eol_))
        if self.yearBuilt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%syearBuilt>%s</%syearBuilt>%s' % (namespace_, self.gds_format_string(quote_xml(self.yearBuilt).encode(ExternalEncoding), input_name='yearBuilt'), namespace_, eol_))
        if self.lotSizeSqFt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slotSizeSqFt>%s</%slotSizeSqFt>%s' % (namespace_, self.gds_format_string(quote_xml(self.lotSizeSqFt).encode(ExternalEncoding), input_name='lotSizeSqFt'), namespace_, eol_))
        if self.finishedSqFt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfinishedSqFt>%s</%sfinishedSqFt>%s' % (namespace_, self.gds_format_string(quote_xml(self.finishedSqFt).encode(ExternalEncoding), input_name='finishedSqFt'), namespace_, eol_))
        if self.bathrooms is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbathrooms>%s</%sbathrooms>%s' % (namespace_, self.gds_format_string(quote_xml(self.bathrooms).encode(ExternalEncoding), input_name='bathrooms'), namespace_, eol_))
        if self.bedrooms is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbedrooms>%s</%sbedrooms>%s' % (namespace_, self.gds_format_string(quote_xml(self.bedrooms).encode(ExternalEncoding), input_name='bedrooms'), namespace_, eol_))
        if self.totalRooms is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalRooms>%s</%stotalRooms>%s' % (namespace_, self.gds_format_string(quote_xml(self.totalRooms).encode(ExternalEncoding), input_name='totalRooms'), namespace_, eol_))
        if self.lastSoldDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slastSoldDate>%s</%slastSoldDate>%s' % (namespace_, self.gds_format_string(quote_xml(self.lastSoldDate).encode(ExternalEncoding), input_name='lastSoldDate'), namespace_, eol_))
        if self.lastSoldPrice is not None:
            self.lastSoldPrice.export(outfile, level, namespace_, name_='lastSoldPrice', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'zpid':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'zpid')
            self.zpid = ival_
        elif nodeName_ == 'links':
            obj_ = Links.factory()
            obj_.build(child_)
            self.links = obj_
            obj_.original_tagname_ = 'links'
        elif nodeName_ == 'address':
            obj_ = Address.factory()
            obj_.build(child_)
            self.address = obj_
            obj_.original_tagname_ = 'address'
        elif nodeName_ == 'FIPScounty':
            FIPScounty_ = child_.text
            FIPScounty_ = self.gds_validate_string(FIPScounty_, node, 'FIPScounty')
            self.FIPScounty = FIPScounty_
        elif nodeName_ == 'useCode':
            useCode_ = child_.text
            useCode_ = self.gds_validate_string(useCode_, node, 'useCode')
            self.useCode = useCode_
        elif nodeName_ == 'taxAssessmentYear':
            taxAssessmentYear_ = child_.text
            taxAssessmentYear_ = self.gds_validate_string(taxAssessmentYear_, node, 'taxAssessmentYear')
            self.taxAssessmentYear = taxAssessmentYear_
        elif nodeName_ == 'taxAssessment':
            taxAssessment_ = child_.text
            taxAssessment_ = self.gds_validate_string(taxAssessment_, node, 'taxAssessment')
            self.taxAssessment = taxAssessment_
        elif nodeName_ == 'yearBuilt':
            yearBuilt_ = child_.text
            yearBuilt_ = self.gds_validate_string(yearBuilt_, node, 'yearBuilt')
            self.yearBuilt = yearBuilt_
        elif nodeName_ == 'lotSizeSqFt':
            lotSizeSqFt_ = child_.text
            lotSizeSqFt_ = self.gds_validate_string(lotSizeSqFt_, node, 'lotSizeSqFt')
            self.lotSizeSqFt = lotSizeSqFt_
        elif nodeName_ == 'finishedSqFt':
            finishedSqFt_ = child_.text
            finishedSqFt_ = self.gds_validate_string(finishedSqFt_, node, 'finishedSqFt')
            self.finishedSqFt = finishedSqFt_
        elif nodeName_ == 'bathrooms':
            bathrooms_ = child_.text
            bathrooms_ = self.gds_validate_string(bathrooms_, node, 'bathrooms')
            self.bathrooms = bathrooms_
        elif nodeName_ == 'bedrooms':
            bedrooms_ = child_.text
            bedrooms_ = self.gds_validate_string(bedrooms_, node, 'bedrooms')
            self.bedrooms = bedrooms_
        elif nodeName_ == 'totalRooms':
            totalRooms_ = child_.text
            totalRooms_ = self.gds_validate_string(totalRooms_, node, 'totalRooms')
            self.totalRooms = totalRooms_
        elif nodeName_ == 'lastSoldDate':
            lastSoldDate_ = child_.text
            lastSoldDate_ = self.gds_validate_string(lastSoldDate_, node, 'lastSoldDate')
            self.lastSoldDate = lastSoldDate_
        elif nodeName_ == 'lastSoldPrice':
            obj_ = Amount.factory()
            obj_.build(child_)
            self.lastSoldPrice = obj_
            obj_.original_tagname_ = 'lastSoldPrice'
# end class Property


class SimpleProperty(Property):
    subclass = None
    superclass = Property
    def __init__(self, zpid=None, links=None, address=None, FIPScounty=None, useCode=None, taxAssessmentYear=None, taxAssessment=None, yearBuilt=None, lotSizeSqFt=None, finishedSqFt=None, bathrooms=None, bedrooms=None, totalRooms=None, lastSoldDate=None, lastSoldPrice=None, zestimate=None, rentzestimate=None, localRealEstate=None, extensiontype_=None):
        self.original_tagname_ = None
        super(SimpleProperty, self).__init__(zpid, links, address, FIPScounty, useCode, taxAssessmentYear, taxAssessment, yearBuilt, lotSizeSqFt, finishedSqFt, bathrooms, bedrooms, totalRooms, lastSoldDate, lastSoldPrice, extensiontype_, )
        self.zestimate = zestimate
        self.rentzestimate = rentzestimate
        self.localRealEstate = localRealEstate
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if SimpleProperty.subclass:
            return SimpleProperty.subclass(*args_, **kwargs_)
        else:
            return SimpleProperty(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_zestimate(self): return self.zestimate
    def set_zestimate(self, zestimate): self.zestimate = zestimate
    def get_rentzestimate(self): return self.rentzestimate
    def set_rentzestimate(self, rentzestimate): self.rentzestimate = rentzestimate
    def get_localRealEstate(self): return self.localRealEstate
    def set_localRealEstate(self, localRealEstate): self.localRealEstate = localRealEstate
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.zestimate is not None or
            self.rentzestimate is not None or
            self.localRealEstate is not None or
            super(SimpleProperty, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='SimpleProperty', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SimpleProperty')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='SimpleProperty', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='SimpleProperty'):
        super(SimpleProperty, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SimpleProperty')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='SimpleProperty', fromsubclass_=False, pretty_print=True):
        super(SimpleProperty, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.zestimate is not None:
            self.zestimate.export(outfile, level, namespace_, name_='zestimate', pretty_print=pretty_print)
        if self.rentzestimate is not None:
            self.rentzestimate.export(outfile, level, namespace_, name_='rentzestimate', pretty_print=pretty_print)
        if self.localRealEstate is not None:
            self.localRealEstate.export(outfile, level, namespace_, name_='localRealEstate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(SimpleProperty, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'zestimate':
            obj_ = Zestimate.factory()
            obj_.build(child_)
            self.zestimate = obj_
            obj_.original_tagname_ = 'zestimate'
        elif nodeName_ == 'rentzestimate':
            obj_ = Zestimate.factory()
            obj_.build(child_)
            self.rentzestimate = obj_
            obj_.original_tagname_ = 'rentzestimate'
        elif nodeName_ == 'localRealEstate':
            obj_ = LocalRealEstate.factory()
            obj_.build(child_)
            self.localRealEstate = obj_
            obj_.original_tagname_ = 'localRealEstate'
        super(SimpleProperty, self).buildChildren(child_, node, nodeName_, True)
# end class SimpleProperty


class TerseAddress(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, st=None, zc=None, cy=None, et=None, la=None, lo=None):
        self.original_tagname_ = None
        self.st = st
        self.zc = zc
        self.cy = cy
        self.et = et
        self.la = la
        self.lo = lo
    def factory(*args_, **kwargs_):
        if TerseAddress.subclass:
            return TerseAddress.subclass(*args_, **kwargs_)
        else:
            return TerseAddress(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_st(self): return self.st
    def set_st(self, st): self.st = st
    def get_zc(self): return self.zc
    def set_zc(self, zc): self.zc = zc
    def get_cy(self): return self.cy
    def set_cy(self, cy): self.cy = cy
    def get_et(self): return self.et
    def set_et(self, et): self.et = et
    def get_la(self): return self.la
    def set_la(self, la): self.la = la
    def get_lo(self): return self.lo
    def set_lo(self, lo): self.lo = lo
    def hasContent_(self):
        if (
            self.st is not None or
            self.zc is not None or
            self.cy is not None or
            self.et is not None or
            self.la is not None or
            self.lo is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='TerseAddress', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TerseAddress')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='TerseAddress', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='TerseAddress'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='TerseAddress', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.st is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sst>%s</%sst>%s' % (namespace_, self.gds_format_string(quote_xml(self.st).encode(ExternalEncoding), input_name='st'), namespace_, eol_))
        if self.zc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%szc>%s</%szc>%s' % (namespace_, self.gds_format_string(quote_xml(self.zc).encode(ExternalEncoding), input_name='zc'), namespace_, eol_))
        if self.cy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scy>%s</%scy>%s' % (namespace_, self.gds_format_string(quote_xml(self.cy).encode(ExternalEncoding), input_name='cy'), namespace_, eol_))
        if self.et is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%set>%s</%set>%s' % (namespace_, self.gds_format_string(quote_xml(self.et).encode(ExternalEncoding), input_name='et'), namespace_, eol_))
        if self.la is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sla>%s</%sla>%s' % (namespace_, self.gds_format_float(self.la, input_name='la'), namespace_, eol_))
        if self.lo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slo>%s</%slo>%s' % (namespace_, self.gds_format_float(self.lo, input_name='lo'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'st':
            st_ = child_.text
            st_ = self.gds_validate_string(st_, node, 'st')
            self.st = st_
        elif nodeName_ == 'zc':
            zc_ = child_.text
            zc_ = self.gds_validate_string(zc_, node, 'zc')
            self.zc = zc_
        elif nodeName_ == 'cy':
            cy_ = child_.text
            cy_ = self.gds_validate_string(cy_, node, 'cy')
            self.cy = cy_
        elif nodeName_ == 'et':
            et_ = child_.text
            et_ = self.gds_validate_string(et_, node, 'et')
            self.et = et_
        elif nodeName_ == 'la':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'la')
            self.la = fval_
        elif nodeName_ == 'lo':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'lo')
            self.lo = fval_
# end class TerseAddress


class ReallySimpleProperty(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, ad=None, pr=None, ba=None, be=None, sf=None, ht=None, hs=None, il=None, fl=None, cp=None, ce=None, hi=None, pc=None):
        self.original_tagname_ = None
        self.id = id
        self.ad = ad
        self.pr = pr
        self.ba = ba
        self.be = be
        self.sf = sf
        self.ht = ht
        self.validate_HomeType(self.ht)
        self.hs = hs
        self.validate_HomeStatus(self.hs)
        self.il = il
        self.fl = fl
        self.cp = cp
        self.ce = ce
        self.hi = hi
        self.pc = pc
    def factory(*args_, **kwargs_):
        if ReallySimpleProperty.subclass:
            return ReallySimpleProperty.subclass(*args_, **kwargs_)
        else:
            return ReallySimpleProperty(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_ad(self): return self.ad
    def set_ad(self, ad): self.ad = ad
    def get_pr(self): return self.pr
    def set_pr(self, pr): self.pr = pr
    def get_ba(self): return self.ba
    def set_ba(self, ba): self.ba = ba
    def get_be(self): return self.be
    def set_be(self, be): self.be = be
    def get_sf(self): return self.sf
    def set_sf(self, sf): self.sf = sf
    def get_ht(self): return self.ht
    def set_ht(self, ht): self.ht = ht
    def get_hs(self): return self.hs
    def set_hs(self, hs): self.hs = hs
    def get_il(self): return self.il
    def set_il(self, il): self.il = il
    def get_fl(self): return self.fl
    def set_fl(self, fl): self.fl = fl
    def get_cp(self): return self.cp
    def set_cp(self, cp): self.cp = cp
    def get_ce(self): return self.ce
    def set_ce(self, ce): self.ce = ce
    def get_hi(self): return self.hi
    def set_hi(self, hi): self.hi = hi
    def get_pc(self): return self.pc
    def set_pc(self, pc): self.pc = pc
    def validate_HomeType(self, value):
        # Validate type HomeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['singleFamily', 'condo', 'multiFamily', 'manufactured', 'lot', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on HomeType' % {"value" : value.encode("utf-8")} )
    def validate_HomeStatus(self, value):
        # Validate type HomeStatus, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['forSale', 'makeMeMove', 'recentlySold', 'other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on HomeStatus' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.id is not None or
            self.ad is not None or
            self.pr is not None or
            self.ba is not None or
            self.be is not None or
            self.sf is not None or
            self.ht is not None or
            self.hs is not None or
            self.il is not None or
            self.fl is not None or
            self.cp is not None or
            self.ce is not None or
            self.hi is not None or
            self.pc is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='ReallySimpleProperty', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReallySimpleProperty')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='ReallySimpleProperty', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='ReallySimpleProperty'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='ReallySimpleProperty', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespace_, self.gds_format_integer(self.id, input_name='id'), namespace_, eol_))
        if self.ad is not None:
            self.ad.export(outfile, level, namespace_, name_='ad', pretty_print=pretty_print)
        if self.pr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spr>%s</%spr>%s' % (namespace_, self.gds_format_integer(self.pr, input_name='pr'), namespace_, eol_))
        if self.ba is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sba>%s</%sba>%s' % (namespace_, self.gds_format_float(self.ba, input_name='ba'), namespace_, eol_))
        if self.be is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbe>%s</%sbe>%s' % (namespace_, self.gds_format_integer(self.be, input_name='be'), namespace_, eol_))
        if self.sf is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssf>%s</%ssf>%s' % (namespace_, self.gds_format_integer(self.sf, input_name='sf'), namespace_, eol_))
        if self.ht is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sht>%s</%sht>%s' % (namespace_, self.gds_format_string(quote_xml(self.ht).encode(ExternalEncoding), input_name='ht'), namespace_, eol_))
        if self.hs is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shs>%s</%shs>%s' % (namespace_, self.gds_format_string(quote_xml(self.hs).encode(ExternalEncoding), input_name='hs'), namespace_, eol_))
        if self.il is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sil>%s</%sil>%s' % (namespace_, self.gds_format_string(quote_xml(self.il).encode(ExternalEncoding), input_name='il'), namespace_, eol_))
        if self.fl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfl>%s</%sfl>%s' % (namespace_, self.gds_format_boolean(self.fl, input_name='fl'), namespace_, eol_))
        if self.cp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scp>%s</%scp>%s' % (namespace_, self.gds_format_string(quote_xml(self.cp).encode(ExternalEncoding), input_name='cp'), namespace_, eol_))
        if self.ce is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sce>%s</%sce>%s' % (namespace_, self.gds_format_string(quote_xml(self.ce).encode(ExternalEncoding), input_name='ce'), namespace_, eol_))
        if self.hi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shi>%s</%shi>%s' % (namespace_, self.gds_format_boolean(self.hi, input_name='hi'), namespace_, eol_))
        if self.pc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spc>%s</%spc>%s' % (namespace_, self.gds_format_integer(self.pc, input_name='pc'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'id':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
        elif nodeName_ == 'ad':
            obj_ = TerseAddress.factory()
            obj_.build(child_)
            self.ad = obj_
            obj_.original_tagname_ = 'ad'
        elif nodeName_ == 'pr':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'pr')
            self.pr = ival_
        elif nodeName_ == 'ba':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ba')
            self.ba = fval_
        elif nodeName_ == 'be':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'be')
            self.be = ival_
        elif nodeName_ == 'sf':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'sf')
            self.sf = ival_
        elif nodeName_ == 'ht':
            ht_ = child_.text
            ht_ = self.gds_validate_string(ht_, node, 'ht')
            self.ht = ht_
            # validate type HomeType
            self.validate_HomeType(self.ht)
        elif nodeName_ == 'hs':
            hs_ = child_.text
            hs_ = self.gds_validate_string(hs_, node, 'hs')
            self.hs = hs_
            # validate type HomeStatus
            self.validate_HomeStatus(self.hs)
        elif nodeName_ == 'il':
            il_ = child_.text
            il_ = self.gds_validate_string(il_, node, 'il')
            self.il = il_
        elif nodeName_ == 'fl':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'fl')
            self.fl = ival_
        elif nodeName_ == 'cp':
            cp_ = child_.text
            cp_ = self.gds_validate_string(cp_, node, 'cp')
            self.cp = cp_
        elif nodeName_ == 'ce':
            ce_ = child_.text
            ce_ = self.gds_validate_string(ce_, node, 'ce')
            self.ce = ce_
        elif nodeName_ == 'hi':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'hi')
            self.hi = ival_
        elif nodeName_ == 'pc':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'pc')
            self.pc = ival_
# end class ReallySimpleProperty


class FMRProperty(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, address=None, detailPageLink=None, price=None, lastSoldDate=None, lastSoldPrice=None, zestimate=None, bathrooms=None, bedrooms=None, finishedSqFt=None, lotSqFt=None, homeType=None, homeStatus=None, imageLink=None, largeImageLink=None, fsboLink=None, forSaleLink=None, makeMeMoveLink=None, recentlySoldLink=None, localPageLink=None, neighborhood=None):
        self.original_tagname_ = None
        self.address = address
        self.detailPageLink = detailPageLink
        self.price = price
        self.lastSoldDate = lastSoldDate
        self.lastSoldPrice = lastSoldPrice
        self.zestimate = zestimate
        self.bathrooms = bathrooms
        self.bedrooms = bedrooms
        self.finishedSqFt = finishedSqFt
        self.lotSqFt = lotSqFt
        self.homeType = homeType
        self.validate_HomeType(self.homeType)
        self.homeStatus = homeStatus
        self.validate_HomeStatus(self.homeStatus)
        self.imageLink = imageLink
        self.largeImageLink = largeImageLink
        self.fsboLink = fsboLink
        self.forSaleLink = forSaleLink
        self.makeMeMoveLink = makeMeMoveLink
        self.recentlySoldLink = recentlySoldLink
        self.localPageLink = localPageLink
        self.neighborhood = neighborhood
    def factory(*args_, **kwargs_):
        if FMRProperty.subclass:
            return FMRProperty.subclass(*args_, **kwargs_)
        else:
            return FMRProperty(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_address(self): return self.address
    def set_address(self, address): self.address = address
    def get_detailPageLink(self): return self.detailPageLink
    def set_detailPageLink(self, detailPageLink): self.detailPageLink = detailPageLink
    def get_price(self): return self.price
    def set_price(self, price): self.price = price
    def get_lastSoldDate(self): return self.lastSoldDate
    def set_lastSoldDate(self, lastSoldDate): self.lastSoldDate = lastSoldDate
    def get_lastSoldPrice(self): return self.lastSoldPrice
    def set_lastSoldPrice(self, lastSoldPrice): self.lastSoldPrice = lastSoldPrice
    def get_zestimate(self): return self.zestimate
    def set_zestimate(self, zestimate): self.zestimate = zestimate
    def get_bathrooms(self): return self.bathrooms
    def set_bathrooms(self, bathrooms): self.bathrooms = bathrooms
    def get_bedrooms(self): return self.bedrooms
    def set_bedrooms(self, bedrooms): self.bedrooms = bedrooms
    def get_finishedSqFt(self): return self.finishedSqFt
    def set_finishedSqFt(self, finishedSqFt): self.finishedSqFt = finishedSqFt
    def get_lotSqFt(self): return self.lotSqFt
    def set_lotSqFt(self, lotSqFt): self.lotSqFt = lotSqFt
    def get_homeType(self): return self.homeType
    def set_homeType(self, homeType): self.homeType = homeType
    def get_homeStatus(self): return self.homeStatus
    def set_homeStatus(self, homeStatus): self.homeStatus = homeStatus
    def get_imageLink(self): return self.imageLink
    def set_imageLink(self, imageLink): self.imageLink = imageLink
    def get_largeImageLink(self): return self.largeImageLink
    def set_largeImageLink(self, largeImageLink): self.largeImageLink = largeImageLink
    def get_fsboLink(self): return self.fsboLink
    def set_fsboLink(self, fsboLink): self.fsboLink = fsboLink
    def get_forSaleLink(self): return self.forSaleLink
    def set_forSaleLink(self, forSaleLink): self.forSaleLink = forSaleLink
    def get_makeMeMoveLink(self): return self.makeMeMoveLink
    def set_makeMeMoveLink(self, makeMeMoveLink): self.makeMeMoveLink = makeMeMoveLink
    def get_recentlySoldLink(self): return self.recentlySoldLink
    def set_recentlySoldLink(self, recentlySoldLink): self.recentlySoldLink = recentlySoldLink
    def get_localPageLink(self): return self.localPageLink
    def set_localPageLink(self, localPageLink): self.localPageLink = localPageLink
    def get_neighborhood(self): return self.neighborhood
    def set_neighborhood(self, neighborhood): self.neighborhood = neighborhood
    def validate_HomeType(self, value):
        # Validate type HomeType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['singleFamily', 'condo', 'multiFamily', 'manufactured', 'lot', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on HomeType' % {"value" : value.encode("utf-8")} )
    def validate_HomeStatus(self, value):
        # Validate type HomeStatus, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['forSale', 'makeMeMove', 'recentlySold', 'other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on HomeStatus' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.address is not None or
            self.detailPageLink is not None or
            self.price is not None or
            self.lastSoldDate is not None or
            self.lastSoldPrice is not None or
            self.zestimate is not None or
            self.bathrooms is not None or
            self.bedrooms is not None or
            self.finishedSqFt is not None or
            self.lotSqFt is not None or
            self.homeType is not None or
            self.homeStatus is not None or
            self.imageLink is not None or
            self.largeImageLink is not None or
            self.fsboLink is not None or
            self.forSaleLink is not None or
            self.makeMeMoveLink is not None or
            self.recentlySoldLink is not None or
            self.localPageLink is not None or
            self.neighborhood is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='FMRProperty', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FMRProperty')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='FMRProperty', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='FMRProperty'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='FMRProperty', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.address is not None:
            self.address.export(outfile, level, namespace_, name_='address', pretty_print=pretty_print)
        if self.detailPageLink is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdetailPageLink>%s</%sdetailPageLink>%s' % (namespace_, self.gds_format_string(quote_xml(self.detailPageLink).encode(ExternalEncoding), input_name='detailPageLink'), namespace_, eol_))
        if self.price is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprice>%s</%sprice>%s' % (namespace_, self.gds_format_integer(self.price, input_name='price'), namespace_, eol_))
        if self.lastSoldDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slastSoldDate>%s</%slastSoldDate>%s' % (namespace_, self.gds_format_string(quote_xml(self.lastSoldDate).encode(ExternalEncoding), input_name='lastSoldDate'), namespace_, eol_))
        if self.lastSoldPrice is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slastSoldPrice>%s</%slastSoldPrice>%s' % (namespace_, self.gds_format_integer(self.lastSoldPrice, input_name='lastSoldPrice'), namespace_, eol_))
        if self.zestimate is not None:
            self.zestimate.export(outfile, level, namespace_, name_='zestimate', pretty_print=pretty_print)
        if self.bathrooms is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbathrooms>%s</%sbathrooms>%s' % (namespace_, self.gds_format_float(self.bathrooms, input_name='bathrooms'), namespace_, eol_))
        if self.bedrooms is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbedrooms>%s</%sbedrooms>%s' % (namespace_, self.gds_format_integer(self.bedrooms, input_name='bedrooms'), namespace_, eol_))
        if self.finishedSqFt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfinishedSqFt>%s</%sfinishedSqFt>%s' % (namespace_, self.gds_format_integer(self.finishedSqFt, input_name='finishedSqFt'), namespace_, eol_))
        if self.lotSqFt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slotSqFt>%s</%slotSqFt>%s' % (namespace_, self.gds_format_integer(self.lotSqFt, input_name='lotSqFt'), namespace_, eol_))
        if self.homeType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shomeType>%s</%shomeType>%s' % (namespace_, self.gds_format_string(quote_xml(self.homeType).encode(ExternalEncoding), input_name='homeType'), namespace_, eol_))
        if self.homeStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shomeStatus>%s</%shomeStatus>%s' % (namespace_, self.gds_format_string(quote_xml(self.homeStatus).encode(ExternalEncoding), input_name='homeStatus'), namespace_, eol_))
        if self.imageLink is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%simageLink>%s</%simageLink>%s' % (namespace_, self.gds_format_string(quote_xml(self.imageLink).encode(ExternalEncoding), input_name='imageLink'), namespace_, eol_))
        if self.largeImageLink is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slargeImageLink>%s</%slargeImageLink>%s' % (namespace_, self.gds_format_string(quote_xml(self.largeImageLink).encode(ExternalEncoding), input_name='largeImageLink'), namespace_, eol_))
        if self.fsboLink is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfsboLink>%s</%sfsboLink>%s' % (namespace_, self.gds_format_string(quote_xml(self.fsboLink).encode(ExternalEncoding), input_name='fsboLink'), namespace_, eol_))
        if self.forSaleLink is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sforSaleLink>%s</%sforSaleLink>%s' % (namespace_, self.gds_format_string(quote_xml(self.forSaleLink).encode(ExternalEncoding), input_name='forSaleLink'), namespace_, eol_))
        if self.makeMeMoveLink is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smakeMeMoveLink>%s</%smakeMeMoveLink>%s' % (namespace_, self.gds_format_string(quote_xml(self.makeMeMoveLink).encode(ExternalEncoding), input_name='makeMeMoveLink'), namespace_, eol_))
        if self.recentlySoldLink is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srecentlySoldLink>%s</%srecentlySoldLink>%s' % (namespace_, self.gds_format_string(quote_xml(self.recentlySoldLink).encode(ExternalEncoding), input_name='recentlySoldLink'), namespace_, eol_))
        if self.localPageLink is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slocalPageLink>%s</%slocalPageLink>%s' % (namespace_, self.gds_format_string(quote_xml(self.localPageLink).encode(ExternalEncoding), input_name='localPageLink'), namespace_, eol_))
        if self.neighborhood is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sneighborhood>%s</%sneighborhood>%s' % (namespace_, self.gds_format_string(quote_xml(self.neighborhood).encode(ExternalEncoding), input_name='neighborhood'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'address':
            obj_ = RestrictedAddress.factory()
            obj_.build(child_)
            self.address = obj_
            obj_.original_tagname_ = 'address'
        elif nodeName_ == 'detailPageLink':
            detailPageLink_ = child_.text
            detailPageLink_ = self.gds_validate_string(detailPageLink_, node, 'detailPageLink')
            self.detailPageLink = detailPageLink_
        elif nodeName_ == 'price':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'price')
            self.price = ival_
        elif nodeName_ == 'lastSoldDate':
            lastSoldDate_ = child_.text
            lastSoldDate_ = self.gds_validate_string(lastSoldDate_, node, 'lastSoldDate')
            self.lastSoldDate = lastSoldDate_
        elif nodeName_ == 'lastSoldPrice':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'lastSoldPrice')
            self.lastSoldPrice = ival_
        elif nodeName_ == 'zestimate':
            obj_ = SimpleZestimate.factory()
            obj_.build(child_)
            self.zestimate = obj_
            obj_.original_tagname_ = 'zestimate'
        elif nodeName_ == 'bathrooms':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'bathrooms')
            self.bathrooms = fval_
        elif nodeName_ == 'bedrooms':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'bedrooms')
            self.bedrooms = ival_
        elif nodeName_ == 'finishedSqFt':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'finishedSqFt')
            self.finishedSqFt = ival_
        elif nodeName_ == 'lotSqFt':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'lotSqFt')
            self.lotSqFt = ival_
        elif nodeName_ == 'homeType':
            homeType_ = child_.text
            homeType_ = self.gds_validate_string(homeType_, node, 'homeType')
            self.homeType = homeType_
            # validate type HomeType
            self.validate_HomeType(self.homeType)
        elif nodeName_ == 'homeStatus':
            homeStatus_ = child_.text
            homeStatus_ = self.gds_validate_string(homeStatus_, node, 'homeStatus')
            self.homeStatus = homeStatus_
            # validate type HomeStatus
            self.validate_HomeStatus(self.homeStatus)
        elif nodeName_ == 'imageLink':
            imageLink_ = child_.text
            imageLink_ = self.gds_validate_string(imageLink_, node, 'imageLink')
            self.imageLink = imageLink_
        elif nodeName_ == 'largeImageLink':
            largeImageLink_ = child_.text
            largeImageLink_ = self.gds_validate_string(largeImageLink_, node, 'largeImageLink')
            self.largeImageLink = largeImageLink_
        elif nodeName_ == 'fsboLink':
            fsboLink_ = child_.text
            fsboLink_ = self.gds_validate_string(fsboLink_, node, 'fsboLink')
            self.fsboLink = fsboLink_
        elif nodeName_ == 'forSaleLink':
            forSaleLink_ = child_.text
            forSaleLink_ = self.gds_validate_string(forSaleLink_, node, 'forSaleLink')
            self.forSaleLink = forSaleLink_
        elif nodeName_ == 'makeMeMoveLink':
            makeMeMoveLink_ = child_.text
            makeMeMoveLink_ = self.gds_validate_string(makeMeMoveLink_, node, 'makeMeMoveLink')
            self.makeMeMoveLink = makeMeMoveLink_
        elif nodeName_ == 'recentlySoldLink':
            recentlySoldLink_ = child_.text
            recentlySoldLink_ = self.gds_validate_string(recentlySoldLink_, node, 'recentlySoldLink')
            self.recentlySoldLink = recentlySoldLink_
        elif nodeName_ == 'localPageLink':
            localPageLink_ = child_.text
            localPageLink_ = self.gds_validate_string(localPageLink_, node, 'localPageLink')
            self.localPageLink = localPageLink_
        elif nodeName_ == 'neighborhood':
            neighborhood_ = child_.text
            neighborhood_ = self.gds_validate_string(neighborhood_, node, 'neighborhood')
            self.neighborhood = neighborhood_
# end class FMRProperty


class ComparableProperty(SimpleProperty):
    subclass = None
    superclass = SimpleProperty
    def __init__(self, zpid=None, links=None, address=None, FIPScounty=None, useCode=None, taxAssessmentYear=None, taxAssessment=None, yearBuilt=None, lotSizeSqFt=None, finishedSqFt=None, bathrooms=None, bedrooms=None, totalRooms=None, lastSoldDate=None, lastSoldPrice=None, zestimate=None, rentzestimate=None, localRealEstate=None, score=None):
        self.original_tagname_ = None
        super(ComparableProperty, self).__init__(zpid, links, address, FIPScounty, useCode, taxAssessmentYear, taxAssessment, yearBuilt, lotSizeSqFt, finishedSqFt, bathrooms, bedrooms, totalRooms, lastSoldDate, lastSoldPrice, zestimate, rentzestimate, localRealEstate, )
        self.score = _cast(float, score)
    def factory(*args_, **kwargs_):
        if ComparableProperty.subclass:
            return ComparableProperty.subclass(*args_, **kwargs_)
        else:
            return ComparableProperty(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_score(self): return self.score
    def set_score(self, score): self.score = score
    def hasContent_(self):
        if (
            super(ComparableProperty, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='ComparableProperty', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ComparableProperty')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='ComparableProperty', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='ComparableProperty'):
        super(ComparableProperty, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ComparableProperty')
        if self.score is not None and 'score' not in already_processed:
            already_processed.add('score')
            outfile.write(' score="%s"' % self.gds_format_float(self.score, input_name='score'))
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='ComparableProperty', fromsubclass_=False, pretty_print=True):
        super(ComparableProperty, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('score', node)
        if value is not None and 'score' not in already_processed:
            already_processed.add('score')
            try:
                self.score = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (score): %s' % exp)
        super(ComparableProperty, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ComparableProperty, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ComparableProperty


class DetailedProperty(SimpleProperty):
    subclass = None
    superclass = SimpleProperty
    def __init__(self, zpid=None, links=None, address=None, FIPScounty=None, useCode=None, taxAssessmentYear=None, taxAssessment=None, yearBuilt=None, lotSizeSqFt=None, finishedSqFt=None, bathrooms=None, bedrooms=None, totalRooms=None, lastSoldDate=None, lastSoldPrice=None, zestimate=None, rentzestimate=None, localRealEstate=None, regions=None):
        self.original_tagname_ = None
        super(DetailedProperty, self).__init__(zpid, links, address, FIPScounty, useCode, taxAssessmentYear, taxAssessment, yearBuilt, lotSizeSqFt, finishedSqFt, bathrooms, bedrooms, totalRooms, lastSoldDate, lastSoldPrice, zestimate, rentzestimate, localRealEstate, )
        self.regions = regions
    def factory(*args_, **kwargs_):
        if DetailedProperty.subclass:
            return DetailedProperty.subclass(*args_, **kwargs_)
        else:
            return DetailedProperty(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_regions(self): return self.regions
    def set_regions(self, regions): self.regions = regions
    def hasContent_(self):
        if (
            self.regions is not None or
            super(DetailedProperty, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='DetailedProperty', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DetailedProperty')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='DetailedProperty', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='DetailedProperty'):
        super(DetailedProperty, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DetailedProperty')
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='DetailedProperty', fromsubclass_=False, pretty_print=True):
        super(DetailedProperty, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.regions is not None:
            self.regions.export(outfile, level, namespace_, name_='regions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DetailedProperty, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'regions':
            obj_ = Regions.factory()
            obj_.build(child_)
            self.regions = obj_
            obj_.original_tagname_ = 'regions'
        super(DetailedProperty, self).buildChildren(child_, node, nodeName_, True)
# end class DetailedProperty


class DeprecatedType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, deprecated=None, valueOf_=None):
        self.original_tagname_ = None
        self.deprecated = _cast(bool, deprecated)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DeprecatedType.subclass:
            return DeprecatedType.subclass(*args_, **kwargs_)
        else:
            return DeprecatedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_deprecated(self): return self.deprecated
    def set_deprecated(self, deprecated): self.deprecated = deprecated
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='DeprecatedType', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeprecatedType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='DeprecatedType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='DeprecatedType'):
        if self.deprecated is not None and 'deprecated' not in already_processed:
            already_processed.add('deprecated')
            outfile.write(' deprecated="%s"' % self.gds_format_boolean(self.deprecated, input_name='deprecated'))
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='DeprecatedType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('deprecated', node)
        if value is not None and 'deprecated' not in already_processed:
            already_processed.add('deprecated')
            if value in ('true', '1'):
                self.deprecated = True
            elif value in ('false', '0'):
                self.deprecated = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DeprecatedType


class AmountOptional(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, duration=None, currency=None, deprecated=None, valueOf_=None):
        self.original_tagname_ = None
        self.duration = _cast(int, duration)
        self.currency = _cast(None, currency)
        self.deprecated = _cast(bool, deprecated)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AmountOptional.subclass:
            return AmountOptional.subclass(*args_, **kwargs_)
        else:
            return AmountOptional(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_duration(self): return self.duration
    def set_duration(self, duration): self.duration = duration
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_deprecated(self): return self.deprecated
    def set_deprecated(self, deprecated): self.deprecated = deprecated
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='AmountOptional', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AmountOptional')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='AmountOptional', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='AmountOptional'):
        if self.duration is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            outfile.write(' duration="%s"' % self.gds_format_integer(self.duration, input_name='duration'))
        if self.currency is not None and 'currency' not in already_processed:
            already_processed.add('currency')
            outfile.write(' currency=%s' % (quote_attrib(self.currency), ))
        if self.deprecated is not None and 'deprecated' not in already_processed:
            already_processed.add('deprecated')
            outfile.write(' deprecated="%s"' % self.gds_format_boolean(self.deprecated, input_name='deprecated'))
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='AmountOptional', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('duration', node)
        if value is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            try:
                self.duration = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('currency', node)
        if value is not None and 'currency' not in already_processed:
            already_processed.add('currency')
            self.currency = value
        value = find_attr_value_('deprecated', node)
        if value is not None and 'deprecated' not in already_processed:
            already_processed.add('deprecated')
            if value in ('true', '1'):
                self.deprecated = True
            elif value in ('false', '0'):
                self.deprecated = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AmountOptional


class MortgageInterestRate(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, loanType=None, valueOf_=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.loanType = _cast(None, loanType)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if MortgageInterestRate.subclass:
            return MortgageInterestRate.subclass(*args_, **kwargs_)
        else:
            return MortgageInterestRate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_loanType(self): return self.loanType
    def set_loanType(self, loanType): self.loanType = loanType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='MortgageInterestRate', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MortgageInterestRate')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='MortgageInterestRate', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='MortgageInterestRate'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.loanType is not None and 'loanType' not in already_processed:
            already_processed.add('loanType')
            outfile.write(' loanType=%s' % (quote_attrib(self.loanType), ))
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='MortgageInterestRate', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('loanType', node)
        if value is not None and 'loanType' not in already_processed:
            already_processed.add('loanType')
            self.loanType = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MortgageInterestRate


class MortgageRateList(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, rate=None):
        self.original_tagname_ = None
        if rate is None:
            self.rate = []
        else:
            self.rate = rate
    def factory(*args_, **kwargs_):
        if MortgageRateList.subclass:
            return MortgageRateList.subclass(*args_, **kwargs_)
        else:
            return MortgageRateList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rate(self): return self.rate
    def set_rate(self, rate): self.rate = rate
    def add_rate(self, value): self.rate.append(value)
    def insert_rate_at(self, index, value): self.rate.insert(index, value)
    def replace_rate_at(self, index, value): self.rate[index] = value
    def hasContent_(self):
        if (
            self.rate
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='MortgageRateList', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MortgageRateList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='MortgageRateList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='MortgageRateList'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='MortgageRateList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for rate_ in self.rate:
            rate_.export(outfile, level, namespace_, name_='rate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rate':
            obj_ = MortgageInterestRate.factory()
            obj_.build(child_)
            self.rate.append(obj_)
            obj_.original_tagname_ = 'rate'
# end class MortgageRateList


class MortgageRateSummary(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, today=None, lastWeek=None):
        self.original_tagname_ = None
        self.today = today
        self.lastWeek = lastWeek
    def factory(*args_, **kwargs_):
        if MortgageRateSummary.subclass:
            return MortgageRateSummary.subclass(*args_, **kwargs_)
        else:
            return MortgageRateSummary(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_today(self): return self.today
    def set_today(self, today): self.today = today
    def get_lastWeek(self): return self.lastWeek
    def set_lastWeek(self, lastWeek): self.lastWeek = lastWeek
    def hasContent_(self):
        if (
            self.today is not None or
            self.lastWeek is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='MortgageRateSummary', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MortgageRateSummary')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='MortgageRateSummary', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='MortgageRateSummary'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='MortgageRateSummary', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.today is not None:
            self.today.export(outfile, level, namespace_, name_='today', pretty_print=pretty_print)
        if self.lastWeek is not None:
            self.lastWeek.export(outfile, level, namespace_, name_='lastWeek', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'today':
            obj_ = MortgageRateList.factory()
            obj_.build(child_)
            self.today = obj_
            obj_.original_tagname_ = 'today'
        elif nodeName_ == 'lastWeek':
            obj_ = MortgageRateList.factory()
            obj_.build(child_)
            self.lastWeek = obj_
            obj_.original_tagname_ = 'lastWeek'
# end class MortgageRateSummary


class MonthlyPaymentData(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, loanType=None, rate=None, monthlyPrincipalAndInterest=None, monthlyMortgageInsurance=None):
        self.original_tagname_ = None
        self.loanType = _cast(None, loanType)
        self.rate = rate
        self.monthlyPrincipalAndInterest = monthlyPrincipalAndInterest
        self.monthlyMortgageInsurance = monthlyMortgageInsurance
    def factory(*args_, **kwargs_):
        if MonthlyPaymentData.subclass:
            return MonthlyPaymentData.subclass(*args_, **kwargs_)
        else:
            return MonthlyPaymentData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rate(self): return self.rate
    def set_rate(self, rate): self.rate = rate
    def get_monthlyPrincipalAndInterest(self): return self.monthlyPrincipalAndInterest
    def set_monthlyPrincipalAndInterest(self, monthlyPrincipalAndInterest): self.monthlyPrincipalAndInterest = monthlyPrincipalAndInterest
    def get_monthlyMortgageInsurance(self): return self.monthlyMortgageInsurance
    def set_monthlyMortgageInsurance(self, monthlyMortgageInsurance): self.monthlyMortgageInsurance = monthlyMortgageInsurance
    def get_loanType(self): return self.loanType
    def set_loanType(self, loanType): self.loanType = loanType
    def hasContent_(self):
        if (
            self.rate is not None or
            self.monthlyPrincipalAndInterest is not None or
            self.monthlyMortgageInsurance is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='MonthlyPaymentData', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MonthlyPaymentData')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='MonthlyPaymentData', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='MonthlyPaymentData'):
        if self.loanType is not None and 'loanType' not in already_processed:
            already_processed.add('loanType')
            outfile.write(' loanType=%s' % (quote_attrib(self.loanType), ))
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='MonthlyPaymentData', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.rate is not None:
            self.rate.export(outfile, level, namespace_, name_='rate', pretty_print=pretty_print)
        if self.monthlyPrincipalAndInterest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smonthlyPrincipalAndInterest>%s</%smonthlyPrincipalAndInterest>%s' % (namespace_, self.gds_format_integer(self.monthlyPrincipalAndInterest, input_name='monthlyPrincipalAndInterest'), namespace_, eol_))
        if self.monthlyMortgageInsurance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smonthlyMortgageInsurance>%s</%smonthlyMortgageInsurance>%s' % (namespace_, self.gds_format_integer(self.monthlyMortgageInsurance, input_name='monthlyMortgageInsurance'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('loanType', node)
        if value is not None and 'loanType' not in already_processed:
            already_processed.add('loanType')
            self.loanType = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rate':
            obj_ = MortgageInterestRate.factory()
            obj_.build(child_)
            self.rate = obj_
            obj_.original_tagname_ = 'rate'
        elif nodeName_ == 'monthlyPrincipalAndInterest':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'monthlyPrincipalAndInterest')
            self.monthlyPrincipalAndInterest = ival_
        elif nodeName_ == 'monthlyMortgageInsurance':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'monthlyMortgageInsurance')
            self.monthlyMortgageInsurance = ival_
# end class MonthlyPaymentData


class MonthlyPaymentsSummary(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, payment=None, downPayment=None, monthlyPropertyTaxes=None, monthlyHazardInsurance=None):
        self.original_tagname_ = None
        if payment is None:
            self.payment = []
        else:
            self.payment = payment
        self.downPayment = downPayment
        self.monthlyPropertyTaxes = monthlyPropertyTaxes
        self.monthlyHazardInsurance = monthlyHazardInsurance
    def factory(*args_, **kwargs_):
        if MonthlyPaymentsSummary.subclass:
            return MonthlyPaymentsSummary.subclass(*args_, **kwargs_)
        else:
            return MonthlyPaymentsSummary(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_payment(self): return self.payment
    def set_payment(self, payment): self.payment = payment
    def add_payment(self, value): self.payment.append(value)
    def insert_payment_at(self, index, value): self.payment.insert(index, value)
    def replace_payment_at(self, index, value): self.payment[index] = value
    def get_downPayment(self): return self.downPayment
    def set_downPayment(self, downPayment): self.downPayment = downPayment
    def get_monthlyPropertyTaxes(self): return self.monthlyPropertyTaxes
    def set_monthlyPropertyTaxes(self, monthlyPropertyTaxes): self.monthlyPropertyTaxes = monthlyPropertyTaxes
    def get_monthlyHazardInsurance(self): return self.monthlyHazardInsurance
    def set_monthlyHazardInsurance(self, monthlyHazardInsurance): self.monthlyHazardInsurance = monthlyHazardInsurance
    def hasContent_(self):
        if (
            self.payment or
            self.downPayment is not None or
            self.monthlyPropertyTaxes is not None or
            self.monthlyHazardInsurance is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='MonthlyPaymentsSummary', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MonthlyPaymentsSummary')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='MonthlyPaymentsSummary', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='MonthlyPaymentsSummary'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='MonthlyPaymentsSummary', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for payment_ in self.payment:
            payment_.export(outfile, level, namespace_, name_='payment', pretty_print=pretty_print)
        if self.downPayment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdownPayment>%s</%sdownPayment>%s' % (namespace_, self.gds_format_integer(self.downPayment, input_name='downPayment'), namespace_, eol_))
        if self.monthlyPropertyTaxes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smonthlyPropertyTaxes>%s</%smonthlyPropertyTaxes>%s' % (namespace_, self.gds_format_integer(self.monthlyPropertyTaxes, input_name='monthlyPropertyTaxes'), namespace_, eol_))
        if self.monthlyHazardInsurance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smonthlyHazardInsurance>%s</%smonthlyHazardInsurance>%s' % (namespace_, self.gds_format_integer(self.monthlyHazardInsurance, input_name='monthlyHazardInsurance'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'payment':
            obj_ = MonthlyPaymentData.factory()
            obj_.build(child_)
            self.payment.append(obj_)
            obj_.original_tagname_ = 'payment'
        elif nodeName_ == 'downPayment':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'downPayment')
            self.downPayment = ival_
        elif nodeName_ == 'monthlyPropertyTaxes':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'monthlyPropertyTaxes')
            self.monthlyPropertyTaxes = ival_
        elif nodeName_ == 'monthlyHazardInsurance':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'monthlyHazardInsurance')
            self.monthlyHazardInsurance = ival_
# end class MonthlyPaymentsSummary


class MonthlyPaymentsDetails(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, monthlyPrincipalAndInterest=None, monthlyPropertyTaxes=None, monthlyHazardInsurance=None, monthlyPmi=None, monthlyHoaDues=None, totalMonthlyPayment=None, totalPayments=None, totalInterest=None, totalPrincipal=None, totalTaxesFeesAndInsurance=None, amortizationSchedule=None):
        self.original_tagname_ = None
        self.monthlyPrincipalAndInterest = monthlyPrincipalAndInterest
        self.monthlyPropertyTaxes = monthlyPropertyTaxes
        self.monthlyHazardInsurance = monthlyHazardInsurance
        self.monthlyPmi = monthlyPmi
        self.monthlyHoaDues = monthlyHoaDues
        self.totalMonthlyPayment = totalMonthlyPayment
        self.totalPayments = totalPayments
        self.totalInterest = totalInterest
        self.totalPrincipal = totalPrincipal
        self.totalTaxesFeesAndInsurance = totalTaxesFeesAndInsurance
        if amortizationSchedule is None:
            self.amortizationSchedule = []
        else:
            self.amortizationSchedule = amortizationSchedule
    def factory(*args_, **kwargs_):
        if MonthlyPaymentsDetails.subclass:
            return MonthlyPaymentsDetails.subclass(*args_, **kwargs_)
        else:
            return MonthlyPaymentsDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_monthlyPrincipalAndInterest(self): return self.monthlyPrincipalAndInterest
    def set_monthlyPrincipalAndInterest(self, monthlyPrincipalAndInterest): self.monthlyPrincipalAndInterest = monthlyPrincipalAndInterest
    def get_monthlyPropertyTaxes(self): return self.monthlyPropertyTaxes
    def set_monthlyPropertyTaxes(self, monthlyPropertyTaxes): self.monthlyPropertyTaxes = monthlyPropertyTaxes
    def get_monthlyHazardInsurance(self): return self.monthlyHazardInsurance
    def set_monthlyHazardInsurance(self, monthlyHazardInsurance): self.monthlyHazardInsurance = monthlyHazardInsurance
    def get_monthlyPmi(self): return self.monthlyPmi
    def set_monthlyPmi(self, monthlyPmi): self.monthlyPmi = monthlyPmi
    def get_monthlyHoaDues(self): return self.monthlyHoaDues
    def set_monthlyHoaDues(self, monthlyHoaDues): self.monthlyHoaDues = monthlyHoaDues
    def get_totalMonthlyPayment(self): return self.totalMonthlyPayment
    def set_totalMonthlyPayment(self, totalMonthlyPayment): self.totalMonthlyPayment = totalMonthlyPayment
    def get_totalPayments(self): return self.totalPayments
    def set_totalPayments(self, totalPayments): self.totalPayments = totalPayments
    def get_totalInterest(self): return self.totalInterest
    def set_totalInterest(self, totalInterest): self.totalInterest = totalInterest
    def get_totalPrincipal(self): return self.totalPrincipal
    def set_totalPrincipal(self, totalPrincipal): self.totalPrincipal = totalPrincipal
    def get_totalTaxesFeesAndInsurance(self): return self.totalTaxesFeesAndInsurance
    def set_totalTaxesFeesAndInsurance(self, totalTaxesFeesAndInsurance): self.totalTaxesFeesAndInsurance = totalTaxesFeesAndInsurance
    def get_amortizationSchedule(self): return self.amortizationSchedule
    def set_amortizationSchedule(self, amortizationSchedule): self.amortizationSchedule = amortizationSchedule
    def add_amortizationSchedule(self, value): self.amortizationSchedule.append(value)
    def insert_amortizationSchedule_at(self, index, value): self.amortizationSchedule.insert(index, value)
    def replace_amortizationSchedule_at(self, index, value): self.amortizationSchedule[index] = value
    def hasContent_(self):
        if (
            self.monthlyPrincipalAndInterest is not None or
            self.monthlyPropertyTaxes is not None or
            self.monthlyHazardInsurance is not None or
            self.monthlyPmi is not None or
            self.monthlyHoaDues is not None or
            self.totalMonthlyPayment is not None or
            self.totalPayments is not None or
            self.totalInterest is not None or
            self.totalPrincipal is not None or
            self.totalTaxesFeesAndInsurance is not None or
            self.amortizationSchedule
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='MonthlyPaymentsDetails', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MonthlyPaymentsDetails')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='MonthlyPaymentsDetails', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='MonthlyPaymentsDetails'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='MonthlyPaymentsDetails', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.monthlyPrincipalAndInterest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smonthlyPrincipalAndInterest>%s</%smonthlyPrincipalAndInterest>%s' % (namespace_, self.gds_format_integer(self.monthlyPrincipalAndInterest, input_name='monthlyPrincipalAndInterest'), namespace_, eol_))
        if self.monthlyPropertyTaxes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smonthlyPropertyTaxes>%s</%smonthlyPropertyTaxes>%s' % (namespace_, self.gds_format_integer(self.monthlyPropertyTaxes, input_name='monthlyPropertyTaxes'), namespace_, eol_))
        if self.monthlyHazardInsurance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smonthlyHazardInsurance>%s</%smonthlyHazardInsurance>%s' % (namespace_, self.gds_format_integer(self.monthlyHazardInsurance, input_name='monthlyHazardInsurance'), namespace_, eol_))
        if self.monthlyPmi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smonthlyPmi>%s</%smonthlyPmi>%s' % (namespace_, self.gds_format_integer(self.monthlyPmi, input_name='monthlyPmi'), namespace_, eol_))
        if self.monthlyHoaDues is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smonthlyHoaDues>%s</%smonthlyHoaDues>%s' % (namespace_, self.gds_format_integer(self.monthlyHoaDues, input_name='monthlyHoaDues'), namespace_, eol_))
        if self.totalMonthlyPayment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalMonthlyPayment>%s</%stotalMonthlyPayment>%s' % (namespace_, self.gds_format_integer(self.totalMonthlyPayment, input_name='totalMonthlyPayment'), namespace_, eol_))
        if self.totalPayments is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalPayments>%s</%stotalPayments>%s' % (namespace_, self.gds_format_integer(self.totalPayments, input_name='totalPayments'), namespace_, eol_))
        if self.totalInterest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalInterest>%s</%stotalInterest>%s' % (namespace_, self.gds_format_integer(self.totalInterest, input_name='totalInterest'), namespace_, eol_))
        if self.totalPrincipal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalPrincipal>%s</%stotalPrincipal>%s' % (namespace_, self.gds_format_integer(self.totalPrincipal, input_name='totalPrincipal'), namespace_, eol_))
        if self.totalTaxesFeesAndInsurance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalTaxesFeesAndInsurance>%s</%stotalTaxesFeesAndInsurance>%s' % (namespace_, self.gds_format_integer(self.totalTaxesFeesAndInsurance, input_name='totalTaxesFeesAndInsurance'), namespace_, eol_))
        for amortizationSchedule_ in self.amortizationSchedule:
            amortizationSchedule_.export(outfile, level, namespace_, name_='amortizationSchedule', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'monthlyPrincipalAndInterest':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'monthlyPrincipalAndInterest')
            self.monthlyPrincipalAndInterest = ival_
        elif nodeName_ == 'monthlyPropertyTaxes':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'monthlyPropertyTaxes')
            self.monthlyPropertyTaxes = ival_
        elif nodeName_ == 'monthlyHazardInsurance':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'monthlyHazardInsurance')
            self.monthlyHazardInsurance = ival_
        elif nodeName_ == 'monthlyPmi':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'monthlyPmi')
            self.monthlyPmi = ival_
        elif nodeName_ == 'monthlyHoaDues':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'monthlyHoaDues')
            self.monthlyHoaDues = ival_
        elif nodeName_ == 'totalMonthlyPayment':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'totalMonthlyPayment')
            self.totalMonthlyPayment = ival_
        elif nodeName_ == 'totalPayments':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'totalPayments')
            self.totalPayments = ival_
        elif nodeName_ == 'totalInterest':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'totalInterest')
            self.totalInterest = ival_
        elif nodeName_ == 'totalPrincipal':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'totalPrincipal')
            self.totalPrincipal = ival_
        elif nodeName_ == 'totalTaxesFeesAndInsurance':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'totalTaxesFeesAndInsurance')
            self.totalTaxesFeesAndInsurance = ival_
        elif nodeName_ == 'amortizationSchedule':
            obj_ = AmortizationSchedule.factory()
            obj_.build(child_)
            self.amortizationSchedule.append(obj_)
            obj_.original_tagname_ = 'amortizationSchedule'
# end class MonthlyPaymentsDetails


class AmortizationSchedule(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, frequency=None, payment=None):
        self.original_tagname_ = None
        self.frequency = _cast(None, frequency)
        if payment is None:
            self.payment = []
        else:
            self.payment = payment
    def factory(*args_, **kwargs_):
        if AmortizationSchedule.subclass:
            return AmortizationSchedule.subclass(*args_, **kwargs_)
        else:
            return AmortizationSchedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_payment(self): return self.payment
    def set_payment(self, payment): self.payment = payment
    def add_payment(self, value): self.payment.append(value)
    def insert_payment_at(self, index, value): self.payment.insert(index, value)
    def replace_payment_at(self, index, value): self.payment[index] = value
    def get_frequency(self): return self.frequency
    def set_frequency(self, frequency): self.frequency = frequency
    def hasContent_(self):
        if (
            self.payment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='AmortizationSchedule', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AmortizationSchedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='AmortizationSchedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='AmortizationSchedule'):
        if self.frequency is not None and 'frequency' not in already_processed:
            already_processed.add('frequency')
            outfile.write(' frequency=%s' % (self.gds_format_string(quote_attrib(self.frequency).encode(ExternalEncoding), input_name='frequency'), ))
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='AmortizationSchedule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for payment_ in self.payment:
            payment_.export(outfile, level, namespace_, name_='payment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('frequency', node)
        if value is not None and 'frequency' not in already_processed:
            already_processed.add('frequency')
            self.frequency = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'payment':
            obj_ = paymentType.factory()
            obj_.build(child_)
            self.payment.append(obj_)
            obj_.original_tagname_ = 'payment'
# end class AmortizationSchedule


class Refinance(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, totalMonthlySavings=None, currentMonthlyPayment=None, newMonthlyPayment=None, breakEven=None, lifetimeSavings=None, savingsTableSchedule=None):
        self.original_tagname_ = None
        self.totalMonthlySavings = totalMonthlySavings
        self.currentMonthlyPayment = currentMonthlyPayment
        self.newMonthlyPayment = newMonthlyPayment
        self.breakEven = breakEven
        self.lifetimeSavings = lifetimeSavings
        if savingsTableSchedule is None:
            self.savingsTableSchedule = []
        else:
            self.savingsTableSchedule = savingsTableSchedule
    def factory(*args_, **kwargs_):
        if Refinance.subclass:
            return Refinance.subclass(*args_, **kwargs_)
        else:
            return Refinance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_totalMonthlySavings(self): return self.totalMonthlySavings
    def set_totalMonthlySavings(self, totalMonthlySavings): self.totalMonthlySavings = totalMonthlySavings
    def get_currentMonthlyPayment(self): return self.currentMonthlyPayment
    def set_currentMonthlyPayment(self, currentMonthlyPayment): self.currentMonthlyPayment = currentMonthlyPayment
    def get_newMonthlyPayment(self): return self.newMonthlyPayment
    def set_newMonthlyPayment(self, newMonthlyPayment): self.newMonthlyPayment = newMonthlyPayment
    def get_breakEven(self): return self.breakEven
    def set_breakEven(self, breakEven): self.breakEven = breakEven
    def get_lifetimeSavings(self): return self.lifetimeSavings
    def set_lifetimeSavings(self, lifetimeSavings): self.lifetimeSavings = lifetimeSavings
    def get_savingsTableSchedule(self): return self.savingsTableSchedule
    def set_savingsTableSchedule(self, savingsTableSchedule): self.savingsTableSchedule = savingsTableSchedule
    def add_savingsTableSchedule(self, value): self.savingsTableSchedule.append(value)
    def insert_savingsTableSchedule_at(self, index, value): self.savingsTableSchedule.insert(index, value)
    def replace_savingsTableSchedule_at(self, index, value): self.savingsTableSchedule[index] = value
    def hasContent_(self):
        if (
            self.totalMonthlySavings is not None or
            self.currentMonthlyPayment is not None or
            self.newMonthlyPayment is not None or
            self.breakEven is not None or
            self.lifetimeSavings is not None or
            self.savingsTableSchedule
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='Refinance', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Refinance')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='Refinance', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='Refinance'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='Refinance', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.totalMonthlySavings is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalMonthlySavings>%s</%stotalMonthlySavings>%s' % (namespace_, self.gds_format_integer(self.totalMonthlySavings, input_name='totalMonthlySavings'), namespace_, eol_))
        if self.currentMonthlyPayment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scurrentMonthlyPayment>%s</%scurrentMonthlyPayment>%s' % (namespace_, self.gds_format_integer(self.currentMonthlyPayment, input_name='currentMonthlyPayment'), namespace_, eol_))
        if self.newMonthlyPayment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snewMonthlyPayment>%s</%snewMonthlyPayment>%s' % (namespace_, self.gds_format_integer(self.newMonthlyPayment, input_name='newMonthlyPayment'), namespace_, eol_))
        if self.breakEven is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbreakEven>%s</%sbreakEven>%s' % (namespace_, self.gds_format_integer(self.breakEven, input_name='breakEven'), namespace_, eol_))
        if self.lifetimeSavings is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slifetimeSavings>%s</%slifetimeSavings>%s' % (namespace_, self.gds_format_integer(self.lifetimeSavings, input_name='lifetimeSavings'), namespace_, eol_))
        for savingsTableSchedule_ in self.savingsTableSchedule:
            savingsTableSchedule_.export(outfile, level, namespace_, name_='savingsTableSchedule', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'totalMonthlySavings':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'totalMonthlySavings')
            self.totalMonthlySavings = ival_
        elif nodeName_ == 'currentMonthlyPayment':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'currentMonthlyPayment')
            self.currentMonthlyPayment = ival_
        elif nodeName_ == 'newMonthlyPayment':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'newMonthlyPayment')
            self.newMonthlyPayment = ival_
        elif nodeName_ == 'breakEven':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'breakEven')
            self.breakEven = ival_
        elif nodeName_ == 'lifetimeSavings':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'lifetimeSavings')
            self.lifetimeSavings = ival_
        elif nodeName_ == 'savingsTableSchedule':
            obj_ = SavingsTableSchedule.factory()
            obj_.build(child_)
            self.savingsTableSchedule.append(obj_)
            obj_.original_tagname_ = 'savingsTableSchedule'
# end class Refinance


class SavingsTableSchedule(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, frequency=None, payment=None):
        self.original_tagname_ = None
        self.frequency = _cast(None, frequency)
        if payment is None:
            self.payment = []
        else:
            self.payment = payment
    def factory(*args_, **kwargs_):
        if SavingsTableSchedule.subclass:
            return SavingsTableSchedule.subclass(*args_, **kwargs_)
        else:
            return SavingsTableSchedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_payment(self): return self.payment
    def set_payment(self, payment): self.payment = payment
    def add_payment(self, value): self.payment.append(value)
    def insert_payment_at(self, index, value): self.payment.insert(index, value)
    def replace_payment_at(self, index, value): self.payment[index] = value
    def get_frequency(self): return self.frequency
    def set_frequency(self, frequency): self.frequency = frequency
    def hasContent_(self):
        if (
            self.payment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='SavingsTableSchedule', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SavingsTableSchedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='SavingsTableSchedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='SavingsTableSchedule'):
        if self.frequency is not None and 'frequency' not in already_processed:
            already_processed.add('frequency')
            outfile.write(' frequency=%s' % (self.gds_format_string(quote_attrib(self.frequency).encode(ExternalEncoding), input_name='frequency'), ))
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='SavingsTableSchedule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for payment_ in self.payment:
            payment_.export(outfile, level, namespace_, name_='payment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('frequency', node)
        if value is not None and 'frequency' not in already_processed:
            already_processed.add('frequency')
            self.frequency = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'payment':
            obj_ = paymentType2.factory()
            obj_.build(child_)
            self.payment.append(obj_)
            obj_.original_tagname_ = 'payment'
# end class SavingsTableSchedule


class LenderAccountStatus(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, balance=None):
        self.original_tagname_ = None
        self.balance = balance
    def factory(*args_, **kwargs_):
        if LenderAccountStatus.subclass:
            return LenderAccountStatus.subclass(*args_, **kwargs_)
        else:
            return LenderAccountStatus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_balance(self): return self.balance
    def set_balance(self, balance): self.balance = balance
    def hasContent_(self):
        if (
            self.balance is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='LenderAccountStatus', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LenderAccountStatus')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='LenderAccountStatus', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='LenderAccountStatus'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='LenderAccountStatus', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.balance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbalance>%s</%sbalance>%s' % (namespace_, self.gds_format_float(self.balance, input_name='balance'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'balance':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'balance')
            self.balance = fval_
# end class LenderAccountStatus


class DiscountPoints(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, monthlyPrincipalAndInterest=None, monthlyPrincipalAndInterest2=None, costOfPoints=None, costOfPoints2=None, monthlySavings=None, result=None, breakEven=None, totalSavings=None):
        self.original_tagname_ = None
        self.monthlyPrincipalAndInterest = monthlyPrincipalAndInterest
        self.monthlyPrincipalAndInterest2 = monthlyPrincipalAndInterest2
        self.costOfPoints = costOfPoints
        self.costOfPoints2 = costOfPoints2
        self.monthlySavings = monthlySavings
        self.result = result
        self.breakEven = breakEven
        self.totalSavings = totalSavings
    def factory(*args_, **kwargs_):
        if DiscountPoints.subclass:
            return DiscountPoints.subclass(*args_, **kwargs_)
        else:
            return DiscountPoints(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_monthlyPrincipalAndInterest(self): return self.monthlyPrincipalAndInterest
    def set_monthlyPrincipalAndInterest(self, monthlyPrincipalAndInterest): self.monthlyPrincipalAndInterest = monthlyPrincipalAndInterest
    def get_monthlyPrincipalAndInterest2(self): return self.monthlyPrincipalAndInterest2
    def set_monthlyPrincipalAndInterest2(self, monthlyPrincipalAndInterest2): self.monthlyPrincipalAndInterest2 = monthlyPrincipalAndInterest2
    def get_costOfPoints(self): return self.costOfPoints
    def set_costOfPoints(self, costOfPoints): self.costOfPoints = costOfPoints
    def get_costOfPoints2(self): return self.costOfPoints2
    def set_costOfPoints2(self, costOfPoints2): self.costOfPoints2 = costOfPoints2
    def get_monthlySavings(self): return self.monthlySavings
    def set_monthlySavings(self, monthlySavings): self.monthlySavings = monthlySavings
    def get_result(self): return self.result
    def set_result(self, result): self.result = result
    def get_breakEven(self): return self.breakEven
    def set_breakEven(self, breakEven): self.breakEven = breakEven
    def get_totalSavings(self): return self.totalSavings
    def set_totalSavings(self, totalSavings): self.totalSavings = totalSavings
    def hasContent_(self):
        if (
            self.monthlyPrincipalAndInterest is not None or
            self.monthlyPrincipalAndInterest2 is not None or
            self.costOfPoints is not None or
            self.costOfPoints2 is not None or
            self.monthlySavings is not None or
            self.result is not None or
            self.breakEven is not None or
            self.totalSavings is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='DiscountPoints', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DiscountPoints')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='DiscountPoints', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='DiscountPoints'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='DiscountPoints', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.monthlyPrincipalAndInterest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smonthlyPrincipalAndInterest>%s</%smonthlyPrincipalAndInterest>%s' % (namespace_, self.gds_format_integer(self.monthlyPrincipalAndInterest, input_name='monthlyPrincipalAndInterest'), namespace_, eol_))
        if self.monthlyPrincipalAndInterest2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smonthlyPrincipalAndInterest2>%s</%smonthlyPrincipalAndInterest2>%s' % (namespace_, self.gds_format_integer(self.monthlyPrincipalAndInterest2, input_name='monthlyPrincipalAndInterest2'), namespace_, eol_))
        if self.costOfPoints is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scostOfPoints>%s</%scostOfPoints>%s' % (namespace_, self.gds_format_integer(self.costOfPoints, input_name='costOfPoints'), namespace_, eol_))
        if self.costOfPoints2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scostOfPoints2>%s</%scostOfPoints2>%s' % (namespace_, self.gds_format_integer(self.costOfPoints2, input_name='costOfPoints2'), namespace_, eol_))
        if self.monthlySavings is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smonthlySavings>%s</%smonthlySavings>%s' % (namespace_, self.gds_format_integer(self.monthlySavings, input_name='monthlySavings'), namespace_, eol_))
        if self.result is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sresult>%s</%sresult>%s' % (namespace_, self.gds_format_string(quote_xml(self.result).encode(ExternalEncoding), input_name='result'), namespace_, eol_))
        if self.breakEven is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbreakEven>%s</%sbreakEven>%s' % (namespace_, self.gds_format_integer(self.breakEven, input_name='breakEven'), namespace_, eol_))
        if self.totalSavings is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalSavings>%s</%stotalSavings>%s' % (namespace_, self.gds_format_integer(self.totalSavings, input_name='totalSavings'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'monthlyPrincipalAndInterest':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'monthlyPrincipalAndInterest')
            self.monthlyPrincipalAndInterest = ival_
        elif nodeName_ == 'monthlyPrincipalAndInterest2':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'monthlyPrincipalAndInterest2')
            self.monthlyPrincipalAndInterest2 = ival_
        elif nodeName_ == 'costOfPoints':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'costOfPoints')
            self.costOfPoints = ival_
        elif nodeName_ == 'costOfPoints2':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'costOfPoints2')
            self.costOfPoints2 = ival_
        elif nodeName_ == 'monthlySavings':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'monthlySavings')
            self.monthlySavings = ival_
        elif nodeName_ == 'result':
            result_ = child_.text
            result_ = self.gds_validate_string(result_, node, 'result')
            self.result = result_
        elif nodeName_ == 'breakEven':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'breakEven')
            self.breakEven = ival_
        elif nodeName_ == 'totalSavings':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'totalSavings')
            self.totalSavings = ival_
# end class DiscountPoints


class FixedVsAdjustableRate(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, monthlyPrincipalAndInterest=None, monthlyPrincipalAndInterestAdjustable=None, fixedDiscountedPayments=None, adjustableDiscountedPayments=None, fixedRemainingPrincipal=None, adjustableRemainingPrincipal=None, fixedTaxSavings=None, adjustableTaxSavings=None, fixedTotalCost=None, adjustableTotalCost=None, result=None, amortizationSchedule=None):
        self.original_tagname_ = None
        self.monthlyPrincipalAndInterest = monthlyPrincipalAndInterest
        self.monthlyPrincipalAndInterestAdjustable = monthlyPrincipalAndInterestAdjustable
        self.fixedDiscountedPayments = fixedDiscountedPayments
        self.adjustableDiscountedPayments = adjustableDiscountedPayments
        self.fixedRemainingPrincipal = fixedRemainingPrincipal
        self.adjustableRemainingPrincipal = adjustableRemainingPrincipal
        self.fixedTaxSavings = fixedTaxSavings
        self.adjustableTaxSavings = adjustableTaxSavings
        self.fixedTotalCost = fixedTotalCost
        self.adjustableTotalCost = adjustableTotalCost
        self.result = result
        if amortizationSchedule is None:
            self.amortizationSchedule = []
        else:
            self.amortizationSchedule = amortizationSchedule
    def factory(*args_, **kwargs_):
        if FixedVsAdjustableRate.subclass:
            return FixedVsAdjustableRate.subclass(*args_, **kwargs_)
        else:
            return FixedVsAdjustableRate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_monthlyPrincipalAndInterest(self): return self.monthlyPrincipalAndInterest
    def set_monthlyPrincipalAndInterest(self, monthlyPrincipalAndInterest): self.monthlyPrincipalAndInterest = monthlyPrincipalAndInterest
    def get_monthlyPrincipalAndInterestAdjustable(self): return self.monthlyPrincipalAndInterestAdjustable
    def set_monthlyPrincipalAndInterestAdjustable(self, monthlyPrincipalAndInterestAdjustable): self.monthlyPrincipalAndInterestAdjustable = monthlyPrincipalAndInterestAdjustable
    def get_fixedDiscountedPayments(self): return self.fixedDiscountedPayments
    def set_fixedDiscountedPayments(self, fixedDiscountedPayments): self.fixedDiscountedPayments = fixedDiscountedPayments
    def get_adjustableDiscountedPayments(self): return self.adjustableDiscountedPayments
    def set_adjustableDiscountedPayments(self, adjustableDiscountedPayments): self.adjustableDiscountedPayments = adjustableDiscountedPayments
    def get_fixedRemainingPrincipal(self): return self.fixedRemainingPrincipal
    def set_fixedRemainingPrincipal(self, fixedRemainingPrincipal): self.fixedRemainingPrincipal = fixedRemainingPrincipal
    def get_adjustableRemainingPrincipal(self): return self.adjustableRemainingPrincipal
    def set_adjustableRemainingPrincipal(self, adjustableRemainingPrincipal): self.adjustableRemainingPrincipal = adjustableRemainingPrincipal
    def get_fixedTaxSavings(self): return self.fixedTaxSavings
    def set_fixedTaxSavings(self, fixedTaxSavings): self.fixedTaxSavings = fixedTaxSavings
    def get_adjustableTaxSavings(self): return self.adjustableTaxSavings
    def set_adjustableTaxSavings(self, adjustableTaxSavings): self.adjustableTaxSavings = adjustableTaxSavings
    def get_fixedTotalCost(self): return self.fixedTotalCost
    def set_fixedTotalCost(self, fixedTotalCost): self.fixedTotalCost = fixedTotalCost
    def get_adjustableTotalCost(self): return self.adjustableTotalCost
    def set_adjustableTotalCost(self, adjustableTotalCost): self.adjustableTotalCost = adjustableTotalCost
    def get_result(self): return self.result
    def set_result(self, result): self.result = result
    def get_amortizationSchedule(self): return self.amortizationSchedule
    def set_amortizationSchedule(self, amortizationSchedule): self.amortizationSchedule = amortizationSchedule
    def add_amortizationSchedule(self, value): self.amortizationSchedule.append(value)
    def insert_amortizationSchedule_at(self, index, value): self.amortizationSchedule.insert(index, value)
    def replace_amortizationSchedule_at(self, index, value): self.amortizationSchedule[index] = value
    def hasContent_(self):
        if (
            self.monthlyPrincipalAndInterest is not None or
            self.monthlyPrincipalAndInterestAdjustable is not None or
            self.fixedDiscountedPayments is not None or
            self.adjustableDiscountedPayments is not None or
            self.fixedRemainingPrincipal is not None or
            self.adjustableRemainingPrincipal is not None or
            self.fixedTaxSavings is not None or
            self.adjustableTaxSavings is not None or
            self.fixedTotalCost is not None or
            self.adjustableTotalCost is not None or
            self.result is not None or
            self.amortizationSchedule
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='FixedVsAdjustableRate', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FixedVsAdjustableRate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='FixedVsAdjustableRate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='FixedVsAdjustableRate'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='FixedVsAdjustableRate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.monthlyPrincipalAndInterest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smonthlyPrincipalAndInterest>%s</%smonthlyPrincipalAndInterest>%s' % (namespace_, self.gds_format_integer(self.monthlyPrincipalAndInterest, input_name='monthlyPrincipalAndInterest'), namespace_, eol_))
        if self.monthlyPrincipalAndInterestAdjustable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smonthlyPrincipalAndInterestAdjustable>%s</%smonthlyPrincipalAndInterestAdjustable>%s' % (namespace_, self.gds_format_integer(self.monthlyPrincipalAndInterestAdjustable, input_name='monthlyPrincipalAndInterestAdjustable'), namespace_, eol_))
        if self.fixedDiscountedPayments is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfixedDiscountedPayments>%s</%sfixedDiscountedPayments>%s' % (namespace_, self.gds_format_integer(self.fixedDiscountedPayments, input_name='fixedDiscountedPayments'), namespace_, eol_))
        if self.adjustableDiscountedPayments is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sadjustableDiscountedPayments>%s</%sadjustableDiscountedPayments>%s' % (namespace_, self.gds_format_integer(self.adjustableDiscountedPayments, input_name='adjustableDiscountedPayments'), namespace_, eol_))
        if self.fixedRemainingPrincipal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfixedRemainingPrincipal>%s</%sfixedRemainingPrincipal>%s' % (namespace_, self.gds_format_integer(self.fixedRemainingPrincipal, input_name='fixedRemainingPrincipal'), namespace_, eol_))
        if self.adjustableRemainingPrincipal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sadjustableRemainingPrincipal>%s</%sadjustableRemainingPrincipal>%s' % (namespace_, self.gds_format_integer(self.adjustableRemainingPrincipal, input_name='adjustableRemainingPrincipal'), namespace_, eol_))
        if self.fixedTaxSavings is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfixedTaxSavings>%s</%sfixedTaxSavings>%s' % (namespace_, self.gds_format_integer(self.fixedTaxSavings, input_name='fixedTaxSavings'), namespace_, eol_))
        if self.adjustableTaxSavings is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sadjustableTaxSavings>%s</%sadjustableTaxSavings>%s' % (namespace_, self.gds_format_integer(self.adjustableTaxSavings, input_name='adjustableTaxSavings'), namespace_, eol_))
        if self.fixedTotalCost is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfixedTotalCost>%s</%sfixedTotalCost>%s' % (namespace_, self.gds_format_integer(self.fixedTotalCost, input_name='fixedTotalCost'), namespace_, eol_))
        if self.adjustableTotalCost is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sadjustableTotalCost>%s</%sadjustableTotalCost>%s' % (namespace_, self.gds_format_integer(self.adjustableTotalCost, input_name='adjustableTotalCost'), namespace_, eol_))
        if self.result is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sresult>%s</%sresult>%s' % (namespace_, self.gds_format_string(quote_xml(self.result).encode(ExternalEncoding), input_name='result'), namespace_, eol_))
        for amortizationSchedule_ in self.amortizationSchedule:
            amortizationSchedule_.export(outfile, level, namespace_, name_='amortizationSchedule', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'monthlyPrincipalAndInterest':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'monthlyPrincipalAndInterest')
            self.monthlyPrincipalAndInterest = ival_
        elif nodeName_ == 'monthlyPrincipalAndInterestAdjustable':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'monthlyPrincipalAndInterestAdjustable')
            self.monthlyPrincipalAndInterestAdjustable = ival_
        elif nodeName_ == 'fixedDiscountedPayments':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'fixedDiscountedPayments')
            self.fixedDiscountedPayments = ival_
        elif nodeName_ == 'adjustableDiscountedPayments':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'adjustableDiscountedPayments')
            self.adjustableDiscountedPayments = ival_
        elif nodeName_ == 'fixedRemainingPrincipal':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'fixedRemainingPrincipal')
            self.fixedRemainingPrincipal = ival_
        elif nodeName_ == 'adjustableRemainingPrincipal':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'adjustableRemainingPrincipal')
            self.adjustableRemainingPrincipal = ival_
        elif nodeName_ == 'fixedTaxSavings':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'fixedTaxSavings')
            self.fixedTaxSavings = ival_
        elif nodeName_ == 'adjustableTaxSavings':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'adjustableTaxSavings')
            self.adjustableTaxSavings = ival_
        elif nodeName_ == 'fixedTotalCost':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'fixedTotalCost')
            self.fixedTotalCost = ival_
        elif nodeName_ == 'adjustableTotalCost':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'adjustableTotalCost')
            self.adjustableTotalCost = ival_
        elif nodeName_ == 'result':
            result_ = child_.text
            result_ = self.gds_validate_string(result_, node, 'result')
            self.result = result_
        elif nodeName_ == 'amortizationSchedule':
            obj_ = FixedVsAdjustableRateAmortizationSchedule.factory()
            obj_.build(child_)
            self.amortizationSchedule.append(obj_)
            obj_.original_tagname_ = 'amortizationSchedule'
# end class FixedVsAdjustableRate


class FixedVsAdjustableRateAmortizationSchedule(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, frequency=None, Payment=None):
        self.original_tagname_ = None
        self.frequency = _cast(None, frequency)
        if Payment is None:
            self.Payment = []
        else:
            self.Payment = Payment
    def factory(*args_, **kwargs_):
        if FixedVsAdjustableRateAmortizationSchedule.subclass:
            return FixedVsAdjustableRateAmortizationSchedule.subclass(*args_, **kwargs_)
        else:
            return FixedVsAdjustableRateAmortizationSchedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Payment(self): return self.Payment
    def set_Payment(self, Payment): self.Payment = Payment
    def add_Payment(self, value): self.Payment.append(value)
    def insert_Payment_at(self, index, value): self.Payment.insert(index, value)
    def replace_Payment_at(self, index, value): self.Payment[index] = value
    def get_frequency(self): return self.frequency
    def set_frequency(self, frequency): self.frequency = frequency
    def hasContent_(self):
        if (
            self.Payment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='FixedVsAdjustableRateAmortizationSchedule', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FixedVsAdjustableRateAmortizationSchedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='FixedVsAdjustableRateAmortizationSchedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='FixedVsAdjustableRateAmortizationSchedule'):
        if self.frequency is not None and 'frequency' not in already_processed:
            already_processed.add('frequency')
            outfile.write(' frequency=%s' % (self.gds_format_string(quote_attrib(self.frequency).encode(ExternalEncoding), input_name='frequency'), ))
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='FixedVsAdjustableRateAmortizationSchedule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Payment_ in self.Payment:
            Payment_.export(outfile, level, namespace_, name_='Payment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('frequency', node)
        if value is not None and 'frequency' not in already_processed:
            already_processed.add('frequency')
            self.frequency = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Payment':
            obj_ = PaymentType.factory()
            obj_.build(child_)
            self.Payment.append(obj_)
            obj_.original_tagname_ = 'Payment'
# end class FixedVsAdjustableRateAmortizationSchedule


class AdjustableMortgage(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, monthlyPrincipalAndInterest=None, monthlyPrincipalAndInterestAdjusted=None, maximumPayment=None, totalPayments=None, totalInterestPayments=None, amortizationSchedule=None):
        self.original_tagname_ = None
        self.monthlyPrincipalAndInterest = monthlyPrincipalAndInterest
        self.monthlyPrincipalAndInterestAdjusted = monthlyPrincipalAndInterestAdjusted
        self.maximumPayment = maximumPayment
        self.totalPayments = totalPayments
        self.totalInterestPayments = totalInterestPayments
        if amortizationSchedule is None:
            self.amortizationSchedule = []
        else:
            self.amortizationSchedule = amortizationSchedule
    def factory(*args_, **kwargs_):
        if AdjustableMortgage.subclass:
            return AdjustableMortgage.subclass(*args_, **kwargs_)
        else:
            return AdjustableMortgage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_monthlyPrincipalAndInterest(self): return self.monthlyPrincipalAndInterest
    def set_monthlyPrincipalAndInterest(self, monthlyPrincipalAndInterest): self.monthlyPrincipalAndInterest = monthlyPrincipalAndInterest
    def get_monthlyPrincipalAndInterestAdjusted(self): return self.monthlyPrincipalAndInterestAdjusted
    def set_monthlyPrincipalAndInterestAdjusted(self, monthlyPrincipalAndInterestAdjusted): self.monthlyPrincipalAndInterestAdjusted = monthlyPrincipalAndInterestAdjusted
    def get_maximumPayment(self): return self.maximumPayment
    def set_maximumPayment(self, maximumPayment): self.maximumPayment = maximumPayment
    def get_totalPayments(self): return self.totalPayments
    def set_totalPayments(self, totalPayments): self.totalPayments = totalPayments
    def get_totalInterestPayments(self): return self.totalInterestPayments
    def set_totalInterestPayments(self, totalInterestPayments): self.totalInterestPayments = totalInterestPayments
    def get_amortizationSchedule(self): return self.amortizationSchedule
    def set_amortizationSchedule(self, amortizationSchedule): self.amortizationSchedule = amortizationSchedule
    def add_amortizationSchedule(self, value): self.amortizationSchedule.append(value)
    def insert_amortizationSchedule_at(self, index, value): self.amortizationSchedule.insert(index, value)
    def replace_amortizationSchedule_at(self, index, value): self.amortizationSchedule[index] = value
    def hasContent_(self):
        if (
            self.monthlyPrincipalAndInterest is not None or
            self.monthlyPrincipalAndInterestAdjusted is not None or
            self.maximumPayment is not None or
            self.totalPayments is not None or
            self.totalInterestPayments is not None or
            self.amortizationSchedule
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='AdjustableMortgage', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdjustableMortgage')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='AdjustableMortgage', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='AdjustableMortgage'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='AdjustableMortgage', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.monthlyPrincipalAndInterest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smonthlyPrincipalAndInterest>%s</%smonthlyPrincipalAndInterest>%s' % (namespace_, self.gds_format_integer(self.monthlyPrincipalAndInterest, input_name='monthlyPrincipalAndInterest'), namespace_, eol_))
        if self.monthlyPrincipalAndInterestAdjusted is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smonthlyPrincipalAndInterestAdjusted>%s</%smonthlyPrincipalAndInterestAdjusted>%s' % (namespace_, self.gds_format_integer(self.monthlyPrincipalAndInterestAdjusted, input_name='monthlyPrincipalAndInterestAdjusted'), namespace_, eol_))
        if self.maximumPayment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaximumPayment>%s</%smaximumPayment>%s' % (namespace_, self.gds_format_integer(self.maximumPayment, input_name='maximumPayment'), namespace_, eol_))
        if self.totalPayments is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalPayments>%s</%stotalPayments>%s' % (namespace_, self.gds_format_integer(self.totalPayments, input_name='totalPayments'), namespace_, eol_))
        if self.totalInterestPayments is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalInterestPayments>%s</%stotalInterestPayments>%s' % (namespace_, self.gds_format_integer(self.totalInterestPayments, input_name='totalInterestPayments'), namespace_, eol_))
        for amortizationSchedule_ in self.amortizationSchedule:
            amortizationSchedule_.export(outfile, level, namespace_, name_='amortizationSchedule', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'monthlyPrincipalAndInterest':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'monthlyPrincipalAndInterest')
            self.monthlyPrincipalAndInterest = ival_
        elif nodeName_ == 'monthlyPrincipalAndInterestAdjusted':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'monthlyPrincipalAndInterestAdjusted')
            self.monthlyPrincipalAndInterestAdjusted = ival_
        elif nodeName_ == 'maximumPayment':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'maximumPayment')
            self.maximumPayment = ival_
        elif nodeName_ == 'totalPayments':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'totalPayments')
            self.totalPayments = ival_
        elif nodeName_ == 'totalInterestPayments':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'totalInterestPayments')
            self.totalInterestPayments = ival_
        elif nodeName_ == 'amortizationSchedule':
            obj_ = AdjustableMortgageAmortizationSchedule.factory()
            obj_.build(child_)
            self.amortizationSchedule.append(obj_)
            obj_.original_tagname_ = 'amortizationSchedule'
# end class AdjustableMortgage


class AdjustableMortgageAmortizationSchedule(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, frequency=None, Payment=None):
        self.original_tagname_ = None
        self.frequency = _cast(None, frequency)
        if Payment is None:
            self.Payment = []
        else:
            self.Payment = Payment
    def factory(*args_, **kwargs_):
        if AdjustableMortgageAmortizationSchedule.subclass:
            return AdjustableMortgageAmortizationSchedule.subclass(*args_, **kwargs_)
        else:
            return AdjustableMortgageAmortizationSchedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Payment(self): return self.Payment
    def set_Payment(self, Payment): self.Payment = Payment
    def add_Payment(self, value): self.Payment.append(value)
    def insert_Payment_at(self, index, value): self.Payment.insert(index, value)
    def replace_Payment_at(self, index, value): self.Payment[index] = value
    def get_frequency(self): return self.frequency
    def set_frequency(self, frequency): self.frequency = frequency
    def hasContent_(self):
        if (
            self.Payment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='AdjustableMortgageAmortizationSchedule', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdjustableMortgageAmortizationSchedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='AdjustableMortgageAmortizationSchedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='AdjustableMortgageAmortizationSchedule'):
        if self.frequency is not None and 'frequency' not in already_processed:
            already_processed.add('frequency')
            outfile.write(' frequency=%s' % (self.gds_format_string(quote_attrib(self.frequency).encode(ExternalEncoding), input_name='frequency'), ))
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='AdjustableMortgageAmortizationSchedule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Payment_ in self.Payment:
            Payment_.export(outfile, level, namespace_, name_='Payment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('frequency', node)
        if value is not None and 'frequency' not in already_processed:
            already_processed.add('frequency')
            self.frequency = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Payment':
            obj_ = PaymentType3.factory()
            obj_.build(child_)
            self.Payment.append(obj_)
            obj_.original_tagname_ = 'Payment'
# end class AdjustableMortgageAmortizationSchedule


class MortgageTerms(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, monthlyPrincipalAndInterest=None, monthlyPrincipalAndInterest2=None, monthlyPrincipalAndInterest3=None, discountedCost=None, discountedCost2=None, discountedCost3=None, remainingPrincipal=None, remainingPrincipal2=None, remainingPrincipal3=None, taxSavings=None, taxSavings2=None, taxSavings3=None, totalCost=None, totalCost2=None, totalCost3=None, result=None):
        self.original_tagname_ = None
        self.monthlyPrincipalAndInterest = monthlyPrincipalAndInterest
        self.monthlyPrincipalAndInterest2 = monthlyPrincipalAndInterest2
        self.monthlyPrincipalAndInterest3 = monthlyPrincipalAndInterest3
        self.discountedCost = discountedCost
        self.discountedCost2 = discountedCost2
        self.discountedCost3 = discountedCost3
        self.remainingPrincipal = remainingPrincipal
        self.remainingPrincipal2 = remainingPrincipal2
        self.remainingPrincipal3 = remainingPrincipal3
        self.taxSavings = taxSavings
        self.taxSavings2 = taxSavings2
        self.taxSavings3 = taxSavings3
        self.totalCost = totalCost
        self.totalCost2 = totalCost2
        self.totalCost3 = totalCost3
        self.result = result
    def factory(*args_, **kwargs_):
        if MortgageTerms.subclass:
            return MortgageTerms.subclass(*args_, **kwargs_)
        else:
            return MortgageTerms(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_monthlyPrincipalAndInterest(self): return self.monthlyPrincipalAndInterest
    def set_monthlyPrincipalAndInterest(self, monthlyPrincipalAndInterest): self.monthlyPrincipalAndInterest = monthlyPrincipalAndInterest
    def get_monthlyPrincipalAndInterest2(self): return self.monthlyPrincipalAndInterest2
    def set_monthlyPrincipalAndInterest2(self, monthlyPrincipalAndInterest2): self.monthlyPrincipalAndInterest2 = monthlyPrincipalAndInterest2
    def get_monthlyPrincipalAndInterest3(self): return self.monthlyPrincipalAndInterest3
    def set_monthlyPrincipalAndInterest3(self, monthlyPrincipalAndInterest3): self.monthlyPrincipalAndInterest3 = monthlyPrincipalAndInterest3
    def get_discountedCost(self): return self.discountedCost
    def set_discountedCost(self, discountedCost): self.discountedCost = discountedCost
    def get_discountedCost2(self): return self.discountedCost2
    def set_discountedCost2(self, discountedCost2): self.discountedCost2 = discountedCost2
    def get_discountedCost3(self): return self.discountedCost3
    def set_discountedCost3(self, discountedCost3): self.discountedCost3 = discountedCost3
    def get_remainingPrincipal(self): return self.remainingPrincipal
    def set_remainingPrincipal(self, remainingPrincipal): self.remainingPrincipal = remainingPrincipal
    def get_remainingPrincipal2(self): return self.remainingPrincipal2
    def set_remainingPrincipal2(self, remainingPrincipal2): self.remainingPrincipal2 = remainingPrincipal2
    def get_remainingPrincipal3(self): return self.remainingPrincipal3
    def set_remainingPrincipal3(self, remainingPrincipal3): self.remainingPrincipal3 = remainingPrincipal3
    def get_taxSavings(self): return self.taxSavings
    def set_taxSavings(self, taxSavings): self.taxSavings = taxSavings
    def get_taxSavings2(self): return self.taxSavings2
    def set_taxSavings2(self, taxSavings2): self.taxSavings2 = taxSavings2
    def get_taxSavings3(self): return self.taxSavings3
    def set_taxSavings3(self, taxSavings3): self.taxSavings3 = taxSavings3
    def get_totalCost(self): return self.totalCost
    def set_totalCost(self, totalCost): self.totalCost = totalCost
    def get_totalCost2(self): return self.totalCost2
    def set_totalCost2(self, totalCost2): self.totalCost2 = totalCost2
    def get_totalCost3(self): return self.totalCost3
    def set_totalCost3(self, totalCost3): self.totalCost3 = totalCost3
    def get_result(self): return self.result
    def set_result(self, result): self.result = result
    def hasContent_(self):
        if (
            self.monthlyPrincipalAndInterest is not None or
            self.monthlyPrincipalAndInterest2 is not None or
            self.monthlyPrincipalAndInterest3 is not None or
            self.discountedCost is not None or
            self.discountedCost2 is not None or
            self.discountedCost3 is not None or
            self.remainingPrincipal is not None or
            self.remainingPrincipal2 is not None or
            self.remainingPrincipal3 is not None or
            self.taxSavings is not None or
            self.taxSavings2 is not None or
            self.taxSavings3 is not None or
            self.totalCost is not None or
            self.totalCost2 is not None or
            self.totalCost3 is not None or
            self.result is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='MortgageTerms', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MortgageTerms')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='MortgageTerms', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='MortgageTerms'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='MortgageTerms', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.monthlyPrincipalAndInterest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smonthlyPrincipalAndInterest>%s</%smonthlyPrincipalAndInterest>%s' % (namespace_, self.gds_format_integer(self.monthlyPrincipalAndInterest, input_name='monthlyPrincipalAndInterest'), namespace_, eol_))
        if self.monthlyPrincipalAndInterest2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smonthlyPrincipalAndInterest2>%s</%smonthlyPrincipalAndInterest2>%s' % (namespace_, self.gds_format_integer(self.monthlyPrincipalAndInterest2, input_name='monthlyPrincipalAndInterest2'), namespace_, eol_))
        if self.monthlyPrincipalAndInterest3 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smonthlyPrincipalAndInterest3>%s</%smonthlyPrincipalAndInterest3>%s' % (namespace_, self.gds_format_integer(self.monthlyPrincipalAndInterest3, input_name='monthlyPrincipalAndInterest3'), namespace_, eol_))
        if self.discountedCost is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdiscountedCost>%s</%sdiscountedCost>%s' % (namespace_, self.gds_format_integer(self.discountedCost, input_name='discountedCost'), namespace_, eol_))
        if self.discountedCost2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdiscountedCost2>%s</%sdiscountedCost2>%s' % (namespace_, self.gds_format_integer(self.discountedCost2, input_name='discountedCost2'), namespace_, eol_))
        if self.discountedCost3 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdiscountedCost3>%s</%sdiscountedCost3>%s' % (namespace_, self.gds_format_integer(self.discountedCost3, input_name='discountedCost3'), namespace_, eol_))
        if self.remainingPrincipal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sremainingPrincipal>%s</%sremainingPrincipal>%s' % (namespace_, self.gds_format_integer(self.remainingPrincipal, input_name='remainingPrincipal'), namespace_, eol_))
        if self.remainingPrincipal2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sremainingPrincipal2>%s</%sremainingPrincipal2>%s' % (namespace_, self.gds_format_integer(self.remainingPrincipal2, input_name='remainingPrincipal2'), namespace_, eol_))
        if self.remainingPrincipal3 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sremainingPrincipal3>%s</%sremainingPrincipal3>%s' % (namespace_, self.gds_format_integer(self.remainingPrincipal3, input_name='remainingPrincipal3'), namespace_, eol_))
        if self.taxSavings is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%staxSavings>%s</%staxSavings>%s' % (namespace_, self.gds_format_integer(self.taxSavings, input_name='taxSavings'), namespace_, eol_))
        if self.taxSavings2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%staxSavings2>%s</%staxSavings2>%s' % (namespace_, self.gds_format_integer(self.taxSavings2, input_name='taxSavings2'), namespace_, eol_))
        if self.taxSavings3 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%staxSavings3>%s</%staxSavings3>%s' % (namespace_, self.gds_format_integer(self.taxSavings3, input_name='taxSavings3'), namespace_, eol_))
        if self.totalCost is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalCost>%s</%stotalCost>%s' % (namespace_, self.gds_format_integer(self.totalCost, input_name='totalCost'), namespace_, eol_))
        if self.totalCost2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalCost2>%s</%stotalCost2>%s' % (namespace_, self.gds_format_integer(self.totalCost2, input_name='totalCost2'), namespace_, eol_))
        if self.totalCost3 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalCost3>%s</%stotalCost3>%s' % (namespace_, self.gds_format_integer(self.totalCost3, input_name='totalCost3'), namespace_, eol_))
        if self.result is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sresult>%s</%sresult>%s' % (namespace_, self.gds_format_string(quote_xml(self.result).encode(ExternalEncoding), input_name='result'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'monthlyPrincipalAndInterest':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'monthlyPrincipalAndInterest')
            self.monthlyPrincipalAndInterest = ival_
        elif nodeName_ == 'monthlyPrincipalAndInterest2':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'monthlyPrincipalAndInterest2')
            self.monthlyPrincipalAndInterest2 = ival_
        elif nodeName_ == 'monthlyPrincipalAndInterest3':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'monthlyPrincipalAndInterest3')
            self.monthlyPrincipalAndInterest3 = ival_
        elif nodeName_ == 'discountedCost':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'discountedCost')
            self.discountedCost = ival_
        elif nodeName_ == 'discountedCost2':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'discountedCost2')
            self.discountedCost2 = ival_
        elif nodeName_ == 'discountedCost3':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'discountedCost3')
            self.discountedCost3 = ival_
        elif nodeName_ == 'remainingPrincipal':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'remainingPrincipal')
            self.remainingPrincipal = ival_
        elif nodeName_ == 'remainingPrincipal2':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'remainingPrincipal2')
            self.remainingPrincipal2 = ival_
        elif nodeName_ == 'remainingPrincipal3':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'remainingPrincipal3')
            self.remainingPrincipal3 = ival_
        elif nodeName_ == 'taxSavings':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'taxSavings')
            self.taxSavings = ival_
        elif nodeName_ == 'taxSavings2':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'taxSavings2')
            self.taxSavings2 = ival_
        elif nodeName_ == 'taxSavings3':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'taxSavings3')
            self.taxSavings3 = ival_
        elif nodeName_ == 'totalCost':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'totalCost')
            self.totalCost = ival_
        elif nodeName_ == 'totalCost2':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'totalCost2')
            self.totalCost2 = ival_
        elif nodeName_ == 'totalCost3':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'totalCost3')
            self.totalCost3 = ival_
        elif nodeName_ == 'result':
            result_ = child_.text
            result_ = self.gds_validate_string(result_, node, 'result')
            self.result = result_
# end class MortgageTerms


class BiWeeklyPayment(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, monthlyPrincipalAndInterest=None, interestSavings=None, payOffInYears=None, result=None, amortizationSchedule=None, biWeeklyAmortizationSchedule=None):
        self.original_tagname_ = None
        self.monthlyPrincipalAndInterest = monthlyPrincipalAndInterest
        self.interestSavings = interestSavings
        self.payOffInYears = payOffInYears
        self.result = result
        if amortizationSchedule is None:
            self.amortizationSchedule = []
        else:
            self.amortizationSchedule = amortizationSchedule
        if biWeeklyAmortizationSchedule is None:
            self.biWeeklyAmortizationSchedule = []
        else:
            self.biWeeklyAmortizationSchedule = biWeeklyAmortizationSchedule
    def factory(*args_, **kwargs_):
        if BiWeeklyPayment.subclass:
            return BiWeeklyPayment.subclass(*args_, **kwargs_)
        else:
            return BiWeeklyPayment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_monthlyPrincipalAndInterest(self): return self.monthlyPrincipalAndInterest
    def set_monthlyPrincipalAndInterest(self, monthlyPrincipalAndInterest): self.monthlyPrincipalAndInterest = monthlyPrincipalAndInterest
    def get_interestSavings(self): return self.interestSavings
    def set_interestSavings(self, interestSavings): self.interestSavings = interestSavings
    def get_payOffInYears(self): return self.payOffInYears
    def set_payOffInYears(self, payOffInYears): self.payOffInYears = payOffInYears
    def get_result(self): return self.result
    def set_result(self, result): self.result = result
    def get_amortizationSchedule(self): return self.amortizationSchedule
    def set_amortizationSchedule(self, amortizationSchedule): self.amortizationSchedule = amortizationSchedule
    def add_amortizationSchedule(self, value): self.amortizationSchedule.append(value)
    def insert_amortizationSchedule_at(self, index, value): self.amortizationSchedule.insert(index, value)
    def replace_amortizationSchedule_at(self, index, value): self.amortizationSchedule[index] = value
    def get_biWeeklyAmortizationSchedule(self): return self.biWeeklyAmortizationSchedule
    def set_biWeeklyAmortizationSchedule(self, biWeeklyAmortizationSchedule): self.biWeeklyAmortizationSchedule = biWeeklyAmortizationSchedule
    def add_biWeeklyAmortizationSchedule(self, value): self.biWeeklyAmortizationSchedule.append(value)
    def insert_biWeeklyAmortizationSchedule_at(self, index, value): self.biWeeklyAmortizationSchedule.insert(index, value)
    def replace_biWeeklyAmortizationSchedule_at(self, index, value): self.biWeeklyAmortizationSchedule[index] = value
    def hasContent_(self):
        if (
            self.monthlyPrincipalAndInterest is not None or
            self.interestSavings is not None or
            self.payOffInYears is not None or
            self.result is not None or
            self.amortizationSchedule or
            self.biWeeklyAmortizationSchedule
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='BiWeeklyPayment', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BiWeeklyPayment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='BiWeeklyPayment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='BiWeeklyPayment'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='BiWeeklyPayment', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.monthlyPrincipalAndInterest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smonthlyPrincipalAndInterest>%s</%smonthlyPrincipalAndInterest>%s' % (namespace_, self.gds_format_integer(self.monthlyPrincipalAndInterest, input_name='monthlyPrincipalAndInterest'), namespace_, eol_))
        if self.interestSavings is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinterestSavings>%s</%sinterestSavings>%s' % (namespace_, self.gds_format_integer(self.interestSavings, input_name='interestSavings'), namespace_, eol_))
        if self.payOffInYears is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spayOffInYears>%s</%spayOffInYears>%s' % (namespace_, self.gds_format_string(quote_xml(self.payOffInYears).encode(ExternalEncoding), input_name='payOffInYears'), namespace_, eol_))
        if self.result is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sresult>%s</%sresult>%s' % (namespace_, self.gds_format_string(quote_xml(self.result).encode(ExternalEncoding), input_name='result'), namespace_, eol_))
        for amortizationSchedule_ in self.amortizationSchedule:
            amortizationSchedule_.export(outfile, level, namespace_, name_='amortizationSchedule', pretty_print=pretty_print)
        for biWeeklyAmortizationSchedule_ in self.biWeeklyAmortizationSchedule:
            biWeeklyAmortizationSchedule_.export(outfile, level, namespace_, name_='biWeeklyAmortizationSchedule', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'monthlyPrincipalAndInterest':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'monthlyPrincipalAndInterest')
            self.monthlyPrincipalAndInterest = ival_
        elif nodeName_ == 'interestSavings':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'interestSavings')
            self.interestSavings = ival_
        elif nodeName_ == 'payOffInYears':
            payOffInYears_ = child_.text
            payOffInYears_ = self.gds_validate_string(payOffInYears_, node, 'payOffInYears')
            self.payOffInYears = payOffInYears_
        elif nodeName_ == 'result':
            result_ = child_.text
            result_ = self.gds_validate_string(result_, node, 'result')
            self.result = result_
        elif nodeName_ == 'amortizationSchedule':
            obj_ = BiWeeklyPaymentAmortizationSchedule.factory()
            obj_.build(child_)
            self.amortizationSchedule.append(obj_)
            obj_.original_tagname_ = 'amortizationSchedule'
        elif nodeName_ == 'biWeeklyAmortizationSchedule':
            obj_ = BiWeeklyPaymentAmortizationSchedule2.factory()
            obj_.build(child_)
            self.biWeeklyAmortizationSchedule.append(obj_)
            obj_.original_tagname_ = 'biWeeklyAmortizationSchedule'
# end class BiWeeklyPayment


class BiWeeklyPaymentAmortizationSchedule(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, frequency=None, Payment=None):
        self.original_tagname_ = None
        self.frequency = _cast(None, frequency)
        if Payment is None:
            self.Payment = []
        else:
            self.Payment = Payment
    def factory(*args_, **kwargs_):
        if BiWeeklyPaymentAmortizationSchedule.subclass:
            return BiWeeklyPaymentAmortizationSchedule.subclass(*args_, **kwargs_)
        else:
            return BiWeeklyPaymentAmortizationSchedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Payment(self): return self.Payment
    def set_Payment(self, Payment): self.Payment = Payment
    def add_Payment(self, value): self.Payment.append(value)
    def insert_Payment_at(self, index, value): self.Payment.insert(index, value)
    def replace_Payment_at(self, index, value): self.Payment[index] = value
    def get_frequency(self): return self.frequency
    def set_frequency(self, frequency): self.frequency = frequency
    def hasContent_(self):
        if (
            self.Payment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='BiWeeklyPaymentAmortizationSchedule', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BiWeeklyPaymentAmortizationSchedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='BiWeeklyPaymentAmortizationSchedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='BiWeeklyPaymentAmortizationSchedule'):
        if self.frequency is not None and 'frequency' not in already_processed:
            already_processed.add('frequency')
            outfile.write(' frequency=%s' % (self.gds_format_string(quote_attrib(self.frequency).encode(ExternalEncoding), input_name='frequency'), ))
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='BiWeeklyPaymentAmortizationSchedule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Payment_ in self.Payment:
            Payment_.export(outfile, level, namespace_, name_='Payment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('frequency', node)
        if value is not None and 'frequency' not in already_processed:
            already_processed.add('frequency')
            self.frequency = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Payment':
            obj_ = PaymentType4.factory()
            obj_.build(child_)
            self.Payment.append(obj_)
            obj_.original_tagname_ = 'Payment'
# end class BiWeeklyPaymentAmortizationSchedule


class BiWeeklyPaymentAmortizationSchedule2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, frequency=None, Payment=None):
        self.original_tagname_ = None
        self.frequency = _cast(None, frequency)
        if Payment is None:
            self.Payment = []
        else:
            self.Payment = Payment
    def factory(*args_, **kwargs_):
        if BiWeeklyPaymentAmortizationSchedule2.subclass:
            return BiWeeklyPaymentAmortizationSchedule2.subclass(*args_, **kwargs_)
        else:
            return BiWeeklyPaymentAmortizationSchedule2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Payment(self): return self.Payment
    def set_Payment(self, Payment): self.Payment = Payment
    def add_Payment(self, value): self.Payment.append(value)
    def insert_Payment_at(self, index, value): self.Payment.insert(index, value)
    def replace_Payment_at(self, index, value): self.Payment[index] = value
    def get_frequency(self): return self.frequency
    def set_frequency(self, frequency): self.frequency = frequency
    def hasContent_(self):
        if (
            self.Payment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='BiWeeklyPaymentAmortizationSchedule2', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BiWeeklyPaymentAmortizationSchedule2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='BiWeeklyPaymentAmortizationSchedule2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='BiWeeklyPaymentAmortizationSchedule2'):
        if self.frequency is not None and 'frequency' not in already_processed:
            already_processed.add('frequency')
            outfile.write(' frequency=%s' % (self.gds_format_string(quote_attrib(self.frequency).encode(ExternalEncoding), input_name='frequency'), ))
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='BiWeeklyPaymentAmortizationSchedule2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Payment_ in self.Payment:
            Payment_.export(outfile, level, namespace_, name_='Payment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('frequency', node)
        if value is not None and 'frequency' not in already_processed:
            already_processed.add('frequency')
            self.frequency = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Payment':
            obj_ = PaymentType5.factory()
            obj_.build(child_)
            self.Payment.append(obj_)
            obj_.original_tagname_ = 'Payment'
# end class BiWeeklyPaymentAmortizationSchedule2


class TaxSavings(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, monthlyPrincipalAndInterest=None, taxSavings=None, result=None, amortizationSchedule=None):
        self.original_tagname_ = None
        self.monthlyPrincipalAndInterest = monthlyPrincipalAndInterest
        self.taxSavings = taxSavings
        self.result = result
        if amortizationSchedule is None:
            self.amortizationSchedule = []
        else:
            self.amortizationSchedule = amortizationSchedule
    def factory(*args_, **kwargs_):
        if TaxSavings.subclass:
            return TaxSavings.subclass(*args_, **kwargs_)
        else:
            return TaxSavings(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_monthlyPrincipalAndInterest(self): return self.monthlyPrincipalAndInterest
    def set_monthlyPrincipalAndInterest(self, monthlyPrincipalAndInterest): self.monthlyPrincipalAndInterest = monthlyPrincipalAndInterest
    def get_taxSavings(self): return self.taxSavings
    def set_taxSavings(self, taxSavings): self.taxSavings = taxSavings
    def get_result(self): return self.result
    def set_result(self, result): self.result = result
    def get_amortizationSchedule(self): return self.amortizationSchedule
    def set_amortizationSchedule(self, amortizationSchedule): self.amortizationSchedule = amortizationSchedule
    def add_amortizationSchedule(self, value): self.amortizationSchedule.append(value)
    def insert_amortizationSchedule_at(self, index, value): self.amortizationSchedule.insert(index, value)
    def replace_amortizationSchedule_at(self, index, value): self.amortizationSchedule[index] = value
    def hasContent_(self):
        if (
            self.monthlyPrincipalAndInterest is not None or
            self.taxSavings is not None or
            self.result is not None or
            self.amortizationSchedule
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='TaxSavings', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TaxSavings')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='TaxSavings', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='TaxSavings'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='TaxSavings', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.monthlyPrincipalAndInterest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smonthlyPrincipalAndInterest>%s</%smonthlyPrincipalAndInterest>%s' % (namespace_, self.gds_format_integer(self.monthlyPrincipalAndInterest, input_name='monthlyPrincipalAndInterest'), namespace_, eol_))
        if self.taxSavings is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%staxSavings>%s</%staxSavings>%s' % (namespace_, self.gds_format_integer(self.taxSavings, input_name='taxSavings'), namespace_, eol_))
        if self.result is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sresult>%s</%sresult>%s' % (namespace_, self.gds_format_string(quote_xml(self.result).encode(ExternalEncoding), input_name='result'), namespace_, eol_))
        for amortizationSchedule_ in self.amortizationSchedule:
            amortizationSchedule_.export(outfile, level, namespace_, name_='amortizationSchedule', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'monthlyPrincipalAndInterest':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'monthlyPrincipalAndInterest')
            self.monthlyPrincipalAndInterest = ival_
        elif nodeName_ == 'taxSavings':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'taxSavings')
            self.taxSavings = ival_
        elif nodeName_ == 'result':
            result_ = child_.text
            result_ = self.gds_validate_string(result_, node, 'result')
            self.result = result_
        elif nodeName_ == 'amortizationSchedule':
            obj_ = TaxSavingsAmortizationSchedule.factory()
            obj_.build(child_)
            self.amortizationSchedule.append(obj_)
            obj_.original_tagname_ = 'amortizationSchedule'
# end class TaxSavings


class TaxSavingsAmortizationSchedule(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, frequency=None, Payment=None):
        self.original_tagname_ = None
        self.frequency = _cast(None, frequency)
        if Payment is None:
            self.Payment = []
        else:
            self.Payment = Payment
    def factory(*args_, **kwargs_):
        if TaxSavingsAmortizationSchedule.subclass:
            return TaxSavingsAmortizationSchedule.subclass(*args_, **kwargs_)
        else:
            return TaxSavingsAmortizationSchedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Payment(self): return self.Payment
    def set_Payment(self, Payment): self.Payment = Payment
    def add_Payment(self, value): self.Payment.append(value)
    def insert_Payment_at(self, index, value): self.Payment.insert(index, value)
    def replace_Payment_at(self, index, value): self.Payment[index] = value
    def get_frequency(self): return self.frequency
    def set_frequency(self, frequency): self.frequency = frequency
    def hasContent_(self):
        if (
            self.Payment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='TaxSavingsAmortizationSchedule', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TaxSavingsAmortizationSchedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='TaxSavingsAmortizationSchedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='TaxSavingsAmortizationSchedule'):
        if self.frequency is not None and 'frequency' not in already_processed:
            already_processed.add('frequency')
            outfile.write(' frequency=%s' % (self.gds_format_string(quote_attrib(self.frequency).encode(ExternalEncoding), input_name='frequency'), ))
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='TaxSavingsAmortizationSchedule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Payment_ in self.Payment:
            Payment_.export(outfile, level, namespace_, name_='Payment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('frequency', node)
        if value is not None and 'frequency' not in already_processed:
            already_processed.add('frequency')
            self.frequency = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Payment':
            obj_ = PaymentType6.factory()
            obj_.build(child_)
            self.Payment.append(obj_)
            obj_.original_tagname_ = 'Payment'
# end class TaxSavingsAmortizationSchedule


class InterstOnlyVsTraditional(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, monthlyPrincipalAndInterest=None, monthlyPrincipalAndInterestInterestOnly=None, monthlyPrincipalAndInterestAdjusted=None, totalInterestPayments=None, totalInterestPaymentsInterestOnly=None, result=None, AmortizationSchedule=None, InterestOnlyAmortizationSchedule=None):
        self.original_tagname_ = None
        self.monthlyPrincipalAndInterest = monthlyPrincipalAndInterest
        self.monthlyPrincipalAndInterestInterestOnly = monthlyPrincipalAndInterestInterestOnly
        self.monthlyPrincipalAndInterestAdjusted = monthlyPrincipalAndInterestAdjusted
        self.totalInterestPayments = totalInterestPayments
        self.totalInterestPaymentsInterestOnly = totalInterestPaymentsInterestOnly
        self.result = result
        if AmortizationSchedule is None:
            self.AmortizationSchedule = []
        else:
            self.AmortizationSchedule = AmortizationSchedule
        if InterestOnlyAmortizationSchedule is None:
            self.InterestOnlyAmortizationSchedule = []
        else:
            self.InterestOnlyAmortizationSchedule = InterestOnlyAmortizationSchedule
    def factory(*args_, **kwargs_):
        if InterstOnlyVsTraditional.subclass:
            return InterstOnlyVsTraditional.subclass(*args_, **kwargs_)
        else:
            return InterstOnlyVsTraditional(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_monthlyPrincipalAndInterest(self): return self.monthlyPrincipalAndInterest
    def set_monthlyPrincipalAndInterest(self, monthlyPrincipalAndInterest): self.monthlyPrincipalAndInterest = monthlyPrincipalAndInterest
    def get_monthlyPrincipalAndInterestInterestOnly(self): return self.monthlyPrincipalAndInterestInterestOnly
    def set_monthlyPrincipalAndInterestInterestOnly(self, monthlyPrincipalAndInterestInterestOnly): self.monthlyPrincipalAndInterestInterestOnly = monthlyPrincipalAndInterestInterestOnly
    def get_monthlyPrincipalAndInterestAdjusted(self): return self.monthlyPrincipalAndInterestAdjusted
    def set_monthlyPrincipalAndInterestAdjusted(self, monthlyPrincipalAndInterestAdjusted): self.monthlyPrincipalAndInterestAdjusted = monthlyPrincipalAndInterestAdjusted
    def get_totalInterestPayments(self): return self.totalInterestPayments
    def set_totalInterestPayments(self, totalInterestPayments): self.totalInterestPayments = totalInterestPayments
    def get_totalInterestPaymentsInterestOnly(self): return self.totalInterestPaymentsInterestOnly
    def set_totalInterestPaymentsInterestOnly(self, totalInterestPaymentsInterestOnly): self.totalInterestPaymentsInterestOnly = totalInterestPaymentsInterestOnly
    def get_result(self): return self.result
    def set_result(self, result): self.result = result
    def get_AmortizationSchedule(self): return self.AmortizationSchedule
    def set_AmortizationSchedule(self, AmortizationSchedule): self.AmortizationSchedule = AmortizationSchedule
    def add_AmortizationSchedule(self, value): self.AmortizationSchedule.append(value)
    def insert_AmortizationSchedule_at(self, index, value): self.AmortizationSchedule.insert(index, value)
    def replace_AmortizationSchedule_at(self, index, value): self.AmortizationSchedule[index] = value
    def get_InterestOnlyAmortizationSchedule(self): return self.InterestOnlyAmortizationSchedule
    def set_InterestOnlyAmortizationSchedule(self, InterestOnlyAmortizationSchedule): self.InterestOnlyAmortizationSchedule = InterestOnlyAmortizationSchedule
    def add_InterestOnlyAmortizationSchedule(self, value): self.InterestOnlyAmortizationSchedule.append(value)
    def insert_InterestOnlyAmortizationSchedule_at(self, index, value): self.InterestOnlyAmortizationSchedule.insert(index, value)
    def replace_InterestOnlyAmortizationSchedule_at(self, index, value): self.InterestOnlyAmortizationSchedule[index] = value
    def hasContent_(self):
        if (
            self.monthlyPrincipalAndInterest is not None or
            self.monthlyPrincipalAndInterestInterestOnly is not None or
            self.monthlyPrincipalAndInterestAdjusted is not None or
            self.totalInterestPayments is not None or
            self.totalInterestPaymentsInterestOnly is not None or
            self.result is not None or
            self.AmortizationSchedule or
            self.InterestOnlyAmortizationSchedule
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='InterstOnlyVsTraditional', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InterstOnlyVsTraditional')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='InterstOnlyVsTraditional', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='InterstOnlyVsTraditional'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='InterstOnlyVsTraditional', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.monthlyPrincipalAndInterest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smonthlyPrincipalAndInterest>%s</%smonthlyPrincipalAndInterest>%s' % (namespace_, self.gds_format_integer(self.monthlyPrincipalAndInterest, input_name='monthlyPrincipalAndInterest'), namespace_, eol_))
        if self.monthlyPrincipalAndInterestInterestOnly is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smonthlyPrincipalAndInterestInterestOnly>%s</%smonthlyPrincipalAndInterestInterestOnly>%s' % (namespace_, self.gds_format_integer(self.monthlyPrincipalAndInterestInterestOnly, input_name='monthlyPrincipalAndInterestInterestOnly'), namespace_, eol_))
        if self.monthlyPrincipalAndInterestAdjusted is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smonthlyPrincipalAndInterestAdjusted>%s</%smonthlyPrincipalAndInterestAdjusted>%s' % (namespace_, self.gds_format_integer(self.monthlyPrincipalAndInterestAdjusted, input_name='monthlyPrincipalAndInterestAdjusted'), namespace_, eol_))
        if self.totalInterestPayments is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalInterestPayments>%s</%stotalInterestPayments>%s' % (namespace_, self.gds_format_integer(self.totalInterestPayments, input_name='totalInterestPayments'), namespace_, eol_))
        if self.totalInterestPaymentsInterestOnly is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalInterestPaymentsInterestOnly>%s</%stotalInterestPaymentsInterestOnly>%s' % (namespace_, self.gds_format_integer(self.totalInterestPaymentsInterestOnly, input_name='totalInterestPaymentsInterestOnly'), namespace_, eol_))
        if self.result is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sresult>%s</%sresult>%s' % (namespace_, self.gds_format_string(quote_xml(self.result).encode(ExternalEncoding), input_name='result'), namespace_, eol_))
        for AmortizationSchedule_ in self.AmortizationSchedule:
            AmortizationSchedule_.export(outfile, level, namespace_, name_='AmortizationSchedule', pretty_print=pretty_print)
        for InterestOnlyAmortizationSchedule_ in self.InterestOnlyAmortizationSchedule:
            InterestOnlyAmortizationSchedule_.export(outfile, level, namespace_, name_='InterestOnlyAmortizationSchedule', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'monthlyPrincipalAndInterest':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'monthlyPrincipalAndInterest')
            self.monthlyPrincipalAndInterest = ival_
        elif nodeName_ == 'monthlyPrincipalAndInterestInterestOnly':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'monthlyPrincipalAndInterestInterestOnly')
            self.monthlyPrincipalAndInterestInterestOnly = ival_
        elif nodeName_ == 'monthlyPrincipalAndInterestAdjusted':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'monthlyPrincipalAndInterestAdjusted')
            self.monthlyPrincipalAndInterestAdjusted = ival_
        elif nodeName_ == 'totalInterestPayments':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'totalInterestPayments')
            self.totalInterestPayments = ival_
        elif nodeName_ == 'totalInterestPaymentsInterestOnly':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'totalInterestPaymentsInterestOnly')
            self.totalInterestPaymentsInterestOnly = ival_
        elif nodeName_ == 'result':
            result_ = child_.text
            result_ = self.gds_validate_string(result_, node, 'result')
            self.result = result_
        elif nodeName_ == 'AmortizationSchedule':
            obj_ = annualAmortizationSchedule.factory()
            obj_.build(child_)
            self.AmortizationSchedule.append(obj_)
            obj_.original_tagname_ = 'AmortizationSchedule'
        elif nodeName_ == 'InterestOnlyAmortizationSchedule':
            obj_ = annualInterestOnlyAmortizationSchedule.factory()
            obj_.build(child_)
            self.InterestOnlyAmortizationSchedule.append(obj_)
            obj_.original_tagname_ = 'InterestOnlyAmortizationSchedule'
# end class InterstOnlyVsTraditional


class annualAmortizationSchedule(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, frequency=None, Payment=None):
        self.original_tagname_ = None
        self.frequency = _cast(None, frequency)
        if Payment is None:
            self.Payment = []
        else:
            self.Payment = Payment
    def factory(*args_, **kwargs_):
        if annualAmortizationSchedule.subclass:
            return annualAmortizationSchedule.subclass(*args_, **kwargs_)
        else:
            return annualAmortizationSchedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Payment(self): return self.Payment
    def set_Payment(self, Payment): self.Payment = Payment
    def add_Payment(self, value): self.Payment.append(value)
    def insert_Payment_at(self, index, value): self.Payment.insert(index, value)
    def replace_Payment_at(self, index, value): self.Payment[index] = value
    def get_frequency(self): return self.frequency
    def set_frequency(self, frequency): self.frequency = frequency
    def hasContent_(self):
        if (
            self.Payment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='annualAmortizationSchedule', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='annualAmortizationSchedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='annualAmortizationSchedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='annualAmortizationSchedule'):
        if self.frequency is not None and 'frequency' not in already_processed:
            already_processed.add('frequency')
            outfile.write(' frequency=%s' % (self.gds_format_string(quote_attrib(self.frequency).encode(ExternalEncoding), input_name='frequency'), ))
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='annualAmortizationSchedule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Payment_ in self.Payment:
            Payment_.export(outfile, level, namespace_, name_='Payment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('frequency', node)
        if value is not None and 'frequency' not in already_processed:
            already_processed.add('frequency')
            self.frequency = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Payment':
            obj_ = PaymentType7.factory()
            obj_.build(child_)
            self.Payment.append(obj_)
            obj_.original_tagname_ = 'Payment'
# end class annualAmortizationSchedule


class annualInterestOnlyAmortizationSchedule(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, frequency=None, Payment=None):
        self.original_tagname_ = None
        self.frequency = _cast(None, frequency)
        if Payment is None:
            self.Payment = []
        else:
            self.Payment = Payment
    def factory(*args_, **kwargs_):
        if annualInterestOnlyAmortizationSchedule.subclass:
            return annualInterestOnlyAmortizationSchedule.subclass(*args_, **kwargs_)
        else:
            return annualInterestOnlyAmortizationSchedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Payment(self): return self.Payment
    def set_Payment(self, Payment): self.Payment = Payment
    def add_Payment(self, value): self.Payment.append(value)
    def insert_Payment_at(self, index, value): self.Payment.insert(index, value)
    def replace_Payment_at(self, index, value): self.Payment[index] = value
    def get_frequency(self): return self.frequency
    def set_frequency(self, frequency): self.frequency = frequency
    def hasContent_(self):
        if (
            self.Payment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='annualInterestOnlyAmortizationSchedule', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='annualInterestOnlyAmortizationSchedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='annualInterestOnlyAmortizationSchedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='annualInterestOnlyAmortizationSchedule'):
        if self.frequency is not None and 'frequency' not in already_processed:
            already_processed.add('frequency')
            outfile.write(' frequency=%s' % (self.gds_format_string(quote_attrib(self.frequency).encode(ExternalEncoding), input_name='frequency'), ))
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='annualInterestOnlyAmortizationSchedule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Payment_ in self.Payment:
            Payment_.export(outfile, level, namespace_, name_='Payment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('frequency', node)
        if value is not None and 'frequency' not in already_processed:
            already_processed.add('frequency')
            self.frequency = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Payment':
            obj_ = PaymentType8.factory()
            obj_.build(child_)
            self.Payment.append(obj_)
            obj_.original_tagname_ = 'Payment'
# end class annualInterestOnlyAmortizationSchedule


class NoCostVsTraditional(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, monthlyPrincipalAndInterest=None, monthlyPrincipalAndInterestNoCost=None, discountedPayments=None, noCostDiscountedPayments=None, remainingPrincipal=None, noCostRemainingPrincipal=None, taxSavings=None, noCostTaxSavings=None, paidAtClose=None, totalCost=None, noCostTotalCost=None, result=None):
        self.original_tagname_ = None
        self.monthlyPrincipalAndInterest = monthlyPrincipalAndInterest
        self.monthlyPrincipalAndInterestNoCost = monthlyPrincipalAndInterestNoCost
        self.discountedPayments = discountedPayments
        self.noCostDiscountedPayments = noCostDiscountedPayments
        self.remainingPrincipal = remainingPrincipal
        self.noCostRemainingPrincipal = noCostRemainingPrincipal
        self.taxSavings = taxSavings
        self.noCostTaxSavings = noCostTaxSavings
        self.paidAtClose = paidAtClose
        self.totalCost = totalCost
        self.noCostTotalCost = noCostTotalCost
        self.result = result
    def factory(*args_, **kwargs_):
        if NoCostVsTraditional.subclass:
            return NoCostVsTraditional.subclass(*args_, **kwargs_)
        else:
            return NoCostVsTraditional(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_monthlyPrincipalAndInterest(self): return self.monthlyPrincipalAndInterest
    def set_monthlyPrincipalAndInterest(self, monthlyPrincipalAndInterest): self.monthlyPrincipalAndInterest = monthlyPrincipalAndInterest
    def get_monthlyPrincipalAndInterestNoCost(self): return self.monthlyPrincipalAndInterestNoCost
    def set_monthlyPrincipalAndInterestNoCost(self, monthlyPrincipalAndInterestNoCost): self.monthlyPrincipalAndInterestNoCost = monthlyPrincipalAndInterestNoCost
    def get_discountedPayments(self): return self.discountedPayments
    def set_discountedPayments(self, discountedPayments): self.discountedPayments = discountedPayments
    def get_noCostDiscountedPayments(self): return self.noCostDiscountedPayments
    def set_noCostDiscountedPayments(self, noCostDiscountedPayments): self.noCostDiscountedPayments = noCostDiscountedPayments
    def get_remainingPrincipal(self): return self.remainingPrincipal
    def set_remainingPrincipal(self, remainingPrincipal): self.remainingPrincipal = remainingPrincipal
    def get_noCostRemainingPrincipal(self): return self.noCostRemainingPrincipal
    def set_noCostRemainingPrincipal(self, noCostRemainingPrincipal): self.noCostRemainingPrincipal = noCostRemainingPrincipal
    def get_taxSavings(self): return self.taxSavings
    def set_taxSavings(self, taxSavings): self.taxSavings = taxSavings
    def get_noCostTaxSavings(self): return self.noCostTaxSavings
    def set_noCostTaxSavings(self, noCostTaxSavings): self.noCostTaxSavings = noCostTaxSavings
    def get_paidAtClose(self): return self.paidAtClose
    def set_paidAtClose(self, paidAtClose): self.paidAtClose = paidAtClose
    def get_totalCost(self): return self.totalCost
    def set_totalCost(self, totalCost): self.totalCost = totalCost
    def get_noCostTotalCost(self): return self.noCostTotalCost
    def set_noCostTotalCost(self, noCostTotalCost): self.noCostTotalCost = noCostTotalCost
    def get_result(self): return self.result
    def set_result(self, result): self.result = result
    def hasContent_(self):
        if (
            self.monthlyPrincipalAndInterest is not None or
            self.monthlyPrincipalAndInterestNoCost is not None or
            self.discountedPayments is not None or
            self.noCostDiscountedPayments is not None or
            self.remainingPrincipal is not None or
            self.noCostRemainingPrincipal is not None or
            self.taxSavings is not None or
            self.noCostTaxSavings is not None or
            self.paidAtClose is not None or
            self.totalCost is not None or
            self.noCostTotalCost is not None or
            self.result is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='NoCostVsTraditional', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NoCostVsTraditional')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='NoCostVsTraditional', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='NoCostVsTraditional'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='NoCostVsTraditional', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.monthlyPrincipalAndInterest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smonthlyPrincipalAndInterest>%s</%smonthlyPrincipalAndInterest>%s' % (namespace_, self.gds_format_integer(self.monthlyPrincipalAndInterest, input_name='monthlyPrincipalAndInterest'), namespace_, eol_))
        if self.monthlyPrincipalAndInterestNoCost is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smonthlyPrincipalAndInterestNoCost>%s</%smonthlyPrincipalAndInterestNoCost>%s' % (namespace_, self.gds_format_integer(self.monthlyPrincipalAndInterestNoCost, input_name='monthlyPrincipalAndInterestNoCost'), namespace_, eol_))
        if self.discountedPayments is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdiscountedPayments>%s</%sdiscountedPayments>%s' % (namespace_, self.gds_format_integer(self.discountedPayments, input_name='discountedPayments'), namespace_, eol_))
        if self.noCostDiscountedPayments is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snoCostDiscountedPayments>%s</%snoCostDiscountedPayments>%s' % (namespace_, self.gds_format_integer(self.noCostDiscountedPayments, input_name='noCostDiscountedPayments'), namespace_, eol_))
        if self.remainingPrincipal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sremainingPrincipal>%s</%sremainingPrincipal>%s' % (namespace_, self.gds_format_integer(self.remainingPrincipal, input_name='remainingPrincipal'), namespace_, eol_))
        if self.noCostRemainingPrincipal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snoCostRemainingPrincipal>%s</%snoCostRemainingPrincipal>%s' % (namespace_, self.gds_format_integer(self.noCostRemainingPrincipal, input_name='noCostRemainingPrincipal'), namespace_, eol_))
        if self.taxSavings is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%staxSavings>%s</%staxSavings>%s' % (namespace_, self.gds_format_integer(self.taxSavings, input_name='taxSavings'), namespace_, eol_))
        if self.noCostTaxSavings is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snoCostTaxSavings>%s</%snoCostTaxSavings>%s' % (namespace_, self.gds_format_integer(self.noCostTaxSavings, input_name='noCostTaxSavings'), namespace_, eol_))
        if self.paidAtClose is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spaidAtClose>%s</%spaidAtClose>%s' % (namespace_, self.gds_format_integer(self.paidAtClose, input_name='paidAtClose'), namespace_, eol_))
        if self.totalCost is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalCost>%s</%stotalCost>%s' % (namespace_, self.gds_format_integer(self.totalCost, input_name='totalCost'), namespace_, eol_))
        if self.noCostTotalCost is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snoCostTotalCost>%s</%snoCostTotalCost>%s' % (namespace_, self.gds_format_integer(self.noCostTotalCost, input_name='noCostTotalCost'), namespace_, eol_))
        if self.result is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sresult>%s</%sresult>%s' % (namespace_, self.gds_format_string(quote_xml(self.result).encode(ExternalEncoding), input_name='result'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'monthlyPrincipalAndInterest':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'monthlyPrincipalAndInterest')
            self.monthlyPrincipalAndInterest = ival_
        elif nodeName_ == 'monthlyPrincipalAndInterestNoCost':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'monthlyPrincipalAndInterestNoCost')
            self.monthlyPrincipalAndInterestNoCost = ival_
        elif nodeName_ == 'discountedPayments':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'discountedPayments')
            self.discountedPayments = ival_
        elif nodeName_ == 'noCostDiscountedPayments':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'noCostDiscountedPayments')
            self.noCostDiscountedPayments = ival_
        elif nodeName_ == 'remainingPrincipal':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'remainingPrincipal')
            self.remainingPrincipal = ival_
        elif nodeName_ == 'noCostRemainingPrincipal':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'noCostRemainingPrincipal')
            self.noCostRemainingPrincipal = ival_
        elif nodeName_ == 'taxSavings':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'taxSavings')
            self.taxSavings = ival_
        elif nodeName_ == 'noCostTaxSavings':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'noCostTaxSavings')
            self.noCostTaxSavings = ival_
        elif nodeName_ == 'paidAtClose':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'paidAtClose')
            self.paidAtClose = ival_
        elif nodeName_ == 'totalCost':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'totalCost')
            self.totalCost = ival_
        elif nodeName_ == 'noCostTotalCost':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'noCostTotalCost')
            self.noCostTotalCost = ival_
        elif nodeName_ == 'result':
            result_ = child_.text
            result_ = self.gds_validate_string(result_, node, 'result')
            self.result = result_
# end class NoCostVsTraditional


class Heloc(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, loanAmount=None, result=None, loanAmountPairs=None):
        self.original_tagname_ = None
        self.loanAmount = loanAmount
        self.result = result
        if loanAmountPairs is None:
            self.loanAmountPairs = []
        else:
            self.loanAmountPairs = loanAmountPairs
    def factory(*args_, **kwargs_):
        if Heloc.subclass:
            return Heloc.subclass(*args_, **kwargs_)
        else:
            return Heloc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_loanAmount(self): return self.loanAmount
    def set_loanAmount(self, loanAmount): self.loanAmount = loanAmount
    def get_result(self): return self.result
    def set_result(self, result): self.result = result
    def get_loanAmountPairs(self): return self.loanAmountPairs
    def set_loanAmountPairs(self, loanAmountPairs): self.loanAmountPairs = loanAmountPairs
    def add_loanAmountPairs(self, value): self.loanAmountPairs.append(value)
    def insert_loanAmountPairs_at(self, index, value): self.loanAmountPairs.insert(index, value)
    def replace_loanAmountPairs_at(self, index, value): self.loanAmountPairs[index] = value
    def hasContent_(self):
        if (
            self.loanAmount is not None or
            self.result is not None or
            self.loanAmountPairs
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='Heloc', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Heloc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='Heloc', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='Heloc'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='Heloc', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.loanAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sloanAmount>%s</%sloanAmount>%s' % (namespace_, self.gds_format_integer(self.loanAmount, input_name='loanAmount'), namespace_, eol_))
        if self.result is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sresult>%s</%sresult>%s' % (namespace_, self.gds_format_string(quote_xml(self.result).encode(ExternalEncoding), input_name='result'), namespace_, eol_))
        for loanAmountPairs_ in self.loanAmountPairs:
            loanAmountPairs_.export(outfile, level, namespace_, name_='loanAmountPairs', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'loanAmount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'loanAmount')
            self.loanAmount = ival_
        elif nodeName_ == 'result':
            result_ = child_.text
            result_ = self.gds_validate_string(result_, node, 'result')
            self.result = result_
        elif nodeName_ == 'loanAmountPairs':
            obj_ = loanAmountPairs.factory()
            obj_.build(child_)
            self.loanAmountPairs.append(obj_)
            obj_.original_tagname_ = 'loanAmountPairs'
# end class Heloc


class loanAmountPairs(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, pairs=None):
        self.original_tagname_ = None
        if pairs is None:
            self.pairs = []
        else:
            self.pairs = pairs
    def factory(*args_, **kwargs_):
        if loanAmountPairs.subclass:
            return loanAmountPairs.subclass(*args_, **kwargs_)
        else:
            return loanAmountPairs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pairs(self): return self.pairs
    def set_pairs(self, pairs): self.pairs = pairs
    def add_pairs(self, value): self.pairs.append(value)
    def insert_pairs_at(self, index, value): self.pairs.insert(index, value)
    def replace_pairs_at(self, index, value): self.pairs[index] = value
    def hasContent_(self):
        if (
            self.pairs
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='loanAmountPairs', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='loanAmountPairs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='loanAmountPairs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='loanAmountPairs'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='loanAmountPairs', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for pairs_ in self.pairs:
            pairs_.export(outfile, level, namespace_, name_='pairs', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pairs':
            obj_ = pairsType.factory()
            obj_.build(child_)
            self.pairs.append(obj_)
            obj_.original_tagname_ = 'pairs'
# end class loanAmountPairs


class RentVsBuy(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, result=None, breakEven=None, totalSavings=None, downPayment=None, closingCosts=None, rentDeposit=None, rentDepositReturn=None, rentBrokerFee=None, yearlyCostsTable=None, cumulativeYearlyCostsTable=None):
        self.original_tagname_ = None
        self.result = result
        self.breakEven = breakEven
        self.totalSavings = totalSavings
        self.downPayment = downPayment
        self.closingCosts = closingCosts
        self.rentDeposit = rentDeposit
        self.rentDepositReturn = rentDepositReturn
        self.rentBrokerFee = rentBrokerFee
        if yearlyCostsTable is None:
            self.yearlyCostsTable = []
        else:
            self.yearlyCostsTable = yearlyCostsTable
        if cumulativeYearlyCostsTable is None:
            self.cumulativeYearlyCostsTable = []
        else:
            self.cumulativeYearlyCostsTable = cumulativeYearlyCostsTable
    def factory(*args_, **kwargs_):
        if RentVsBuy.subclass:
            return RentVsBuy.subclass(*args_, **kwargs_)
        else:
            return RentVsBuy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_result(self): return self.result
    def set_result(self, result): self.result = result
    def get_breakEven(self): return self.breakEven
    def set_breakEven(self, breakEven): self.breakEven = breakEven
    def get_totalSavings(self): return self.totalSavings
    def set_totalSavings(self, totalSavings): self.totalSavings = totalSavings
    def get_downPayment(self): return self.downPayment
    def set_downPayment(self, downPayment): self.downPayment = downPayment
    def get_closingCosts(self): return self.closingCosts
    def set_closingCosts(self, closingCosts): self.closingCosts = closingCosts
    def get_rentDeposit(self): return self.rentDeposit
    def set_rentDeposit(self, rentDeposit): self.rentDeposit = rentDeposit
    def get_rentDepositReturn(self): return self.rentDepositReturn
    def set_rentDepositReturn(self, rentDepositReturn): self.rentDepositReturn = rentDepositReturn
    def get_rentBrokerFee(self): return self.rentBrokerFee
    def set_rentBrokerFee(self, rentBrokerFee): self.rentBrokerFee = rentBrokerFee
    def get_yearlyCostsTable(self): return self.yearlyCostsTable
    def set_yearlyCostsTable(self, yearlyCostsTable): self.yearlyCostsTable = yearlyCostsTable
    def add_yearlyCostsTable(self, value): self.yearlyCostsTable.append(value)
    def insert_yearlyCostsTable_at(self, index, value): self.yearlyCostsTable.insert(index, value)
    def replace_yearlyCostsTable_at(self, index, value): self.yearlyCostsTable[index] = value
    def get_cumulativeYearlyCostsTable(self): return self.cumulativeYearlyCostsTable
    def set_cumulativeYearlyCostsTable(self, cumulativeYearlyCostsTable): self.cumulativeYearlyCostsTable = cumulativeYearlyCostsTable
    def add_cumulativeYearlyCostsTable(self, value): self.cumulativeYearlyCostsTable.append(value)
    def insert_cumulativeYearlyCostsTable_at(self, index, value): self.cumulativeYearlyCostsTable.insert(index, value)
    def replace_cumulativeYearlyCostsTable_at(self, index, value): self.cumulativeYearlyCostsTable[index] = value
    def hasContent_(self):
        if (
            self.result is not None or
            self.breakEven is not None or
            self.totalSavings is not None or
            self.downPayment is not None or
            self.closingCosts is not None or
            self.rentDeposit is not None or
            self.rentDepositReturn is not None or
            self.rentBrokerFee is not None or
            self.yearlyCostsTable or
            self.cumulativeYearlyCostsTable
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='RentVsBuy', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RentVsBuy')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='RentVsBuy', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='RentVsBuy'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='RentVsBuy', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.result is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sresult>%s</%sresult>%s' % (namespace_, self.gds_format_string(quote_xml(self.result).encode(ExternalEncoding), input_name='result'), namespace_, eol_))
        if self.breakEven is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbreakEven>%s</%sbreakEven>%s' % (namespace_, self.gds_format_integer(self.breakEven, input_name='breakEven'), namespace_, eol_))
        if self.totalSavings is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalSavings>%s</%stotalSavings>%s' % (namespace_, self.gds_format_integer(self.totalSavings, input_name='totalSavings'), namespace_, eol_))
        if self.downPayment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdownPayment>%s</%sdownPayment>%s' % (namespace_, self.gds_format_integer(self.downPayment, input_name='downPayment'), namespace_, eol_))
        if self.closingCosts is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sclosingCosts>%s</%sclosingCosts>%s' % (namespace_, self.gds_format_integer(self.closingCosts, input_name='closingCosts'), namespace_, eol_))
        if self.rentDeposit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srentDeposit>%s</%srentDeposit>%s' % (namespace_, self.gds_format_integer(self.rentDeposit, input_name='rentDeposit'), namespace_, eol_))
        if self.rentDepositReturn is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srentDepositReturn>%s</%srentDepositReturn>%s' % (namespace_, self.gds_format_integer(self.rentDepositReturn, input_name='rentDepositReturn'), namespace_, eol_))
        if self.rentBrokerFee is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srentBrokerFee>%s</%srentBrokerFee>%s' % (namespace_, self.gds_format_integer(self.rentBrokerFee, input_name='rentBrokerFee'), namespace_, eol_))
        for yearlyCostsTable_ in self.yearlyCostsTable:
            yearlyCostsTable_.export(outfile, level, namespace_, name_='yearlyCostsTable', pretty_print=pretty_print)
        for cumulativeYearlyCostsTable_ in self.cumulativeYearlyCostsTable:
            cumulativeYearlyCostsTable_.export(outfile, level, namespace_, name_='cumulativeYearlyCostsTable', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'result':
            result_ = child_.text
            result_ = self.gds_validate_string(result_, node, 'result')
            self.result = result_
        elif nodeName_ == 'breakEven':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'breakEven')
            self.breakEven = ival_
        elif nodeName_ == 'totalSavings':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'totalSavings')
            self.totalSavings = ival_
        elif nodeName_ == 'downPayment':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'downPayment')
            self.downPayment = ival_
        elif nodeName_ == 'closingCosts':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'closingCosts')
            self.closingCosts = ival_
        elif nodeName_ == 'rentDeposit':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'rentDeposit')
            self.rentDeposit = ival_
        elif nodeName_ == 'rentDepositReturn':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'rentDepositReturn')
            self.rentDepositReturn = ival_
        elif nodeName_ == 'rentBrokerFee':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'rentBrokerFee')
            self.rentBrokerFee = ival_
        elif nodeName_ == 'yearlyCostsTable':
            obj_ = yearlyCostsTable.factory()
            obj_.build(child_)
            self.yearlyCostsTable.append(obj_)
            obj_.original_tagname_ = 'yearlyCostsTable'
        elif nodeName_ == 'cumulativeYearlyCostsTable':
            obj_ = cumulativeYearlyCostsTable.factory()
            obj_.build(child_)
            self.cumulativeYearlyCostsTable.append(obj_)
            obj_.original_tagname_ = 'cumulativeYearlyCostsTable'
# end class RentVsBuy


class yearlyCostsTable(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, year=None, buyingBlock=None, rentingBlock=None):
        self.original_tagname_ = None
        self.year = year
        if buyingBlock is None:
            self.buyingBlock = []
        else:
            self.buyingBlock = buyingBlock
        if rentingBlock is None:
            self.rentingBlock = []
        else:
            self.rentingBlock = rentingBlock
    def factory(*args_, **kwargs_):
        if yearlyCostsTable.subclass:
            return yearlyCostsTable.subclass(*args_, **kwargs_)
        else:
            return yearlyCostsTable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_year(self): return self.year
    def set_year(self, year): self.year = year
    def get_buyingBlock(self): return self.buyingBlock
    def set_buyingBlock(self, buyingBlock): self.buyingBlock = buyingBlock
    def add_buyingBlock(self, value): self.buyingBlock.append(value)
    def insert_buyingBlock_at(self, index, value): self.buyingBlock.insert(index, value)
    def replace_buyingBlock_at(self, index, value): self.buyingBlock[index] = value
    def get_rentingBlock(self): return self.rentingBlock
    def set_rentingBlock(self, rentingBlock): self.rentingBlock = rentingBlock
    def add_rentingBlock(self, value): self.rentingBlock.append(value)
    def insert_rentingBlock_at(self, index, value): self.rentingBlock.insert(index, value)
    def replace_rentingBlock_at(self, index, value): self.rentingBlock[index] = value
    def hasContent_(self):
        if (
            self.year is not None or
            self.buyingBlock or
            self.rentingBlock
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='yearlyCostsTable', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='yearlyCostsTable')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='yearlyCostsTable', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='yearlyCostsTable'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='yearlyCostsTable', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.year is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%syear>%s</%syear>%s' % (namespace_, self.gds_format_integer(self.year, input_name='year'), namespace_, eol_))
        for buyingBlock_ in self.buyingBlock:
            buyingBlock_.export(outfile, level, namespace_, name_='buyingBlock', pretty_print=pretty_print)
        for rentingBlock_ in self.rentingBlock:
            rentingBlock_.export(outfile, level, namespace_, name_='rentingBlock', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'year':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'year')
            self.year = ival_
        elif nodeName_ == 'buyingBlock':
            obj_ = buyingBlock.factory()
            obj_.build(child_)
            self.buyingBlock.append(obj_)
            obj_.original_tagname_ = 'buyingBlock'
        elif nodeName_ == 'rentingBlock':
            obj_ = rentingBlock.factory()
            obj_.build(child_)
            self.rentingBlock.append(obj_)
            obj_.original_tagname_ = 'rentingBlock'
# end class yearlyCostsTable


class cumulativeYearlyCostsTable(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, year=None, savings=None, buyingBlock=None, sellingBlock=None, rentingBlock=None):
        self.original_tagname_ = None
        self.year = year
        self.savings = savings
        if buyingBlock is None:
            self.buyingBlock = []
        else:
            self.buyingBlock = buyingBlock
        if sellingBlock is None:
            self.sellingBlock = []
        else:
            self.sellingBlock = sellingBlock
        if rentingBlock is None:
            self.rentingBlock = []
        else:
            self.rentingBlock = rentingBlock
    def factory(*args_, **kwargs_):
        if cumulativeYearlyCostsTable.subclass:
            return cumulativeYearlyCostsTable.subclass(*args_, **kwargs_)
        else:
            return cumulativeYearlyCostsTable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_year(self): return self.year
    def set_year(self, year): self.year = year
    def get_savings(self): return self.savings
    def set_savings(self, savings): self.savings = savings
    def get_buyingBlock(self): return self.buyingBlock
    def set_buyingBlock(self, buyingBlock): self.buyingBlock = buyingBlock
    def add_buyingBlock(self, value): self.buyingBlock.append(value)
    def insert_buyingBlock_at(self, index, value): self.buyingBlock.insert(index, value)
    def replace_buyingBlock_at(self, index, value): self.buyingBlock[index] = value
    def get_sellingBlock(self): return self.sellingBlock
    def set_sellingBlock(self, sellingBlock): self.sellingBlock = sellingBlock
    def add_sellingBlock(self, value): self.sellingBlock.append(value)
    def insert_sellingBlock_at(self, index, value): self.sellingBlock.insert(index, value)
    def replace_sellingBlock_at(self, index, value): self.sellingBlock[index] = value
    def get_rentingBlock(self): return self.rentingBlock
    def set_rentingBlock(self, rentingBlock): self.rentingBlock = rentingBlock
    def add_rentingBlock(self, value): self.rentingBlock.append(value)
    def insert_rentingBlock_at(self, index, value): self.rentingBlock.insert(index, value)
    def replace_rentingBlock_at(self, index, value): self.rentingBlock[index] = value
    def hasContent_(self):
        if (
            self.year is not None or
            self.savings is not None or
            self.buyingBlock or
            self.sellingBlock or
            self.rentingBlock
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='cumulativeYearlyCostsTable', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cumulativeYearlyCostsTable')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='cumulativeYearlyCostsTable', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='cumulativeYearlyCostsTable'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='cumulativeYearlyCostsTable', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.year is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%syear>%s</%syear>%s' % (namespace_, self.gds_format_integer(self.year, input_name='year'), namespace_, eol_))
        if self.savings is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssavings>%s</%ssavings>%s' % (namespace_, self.gds_format_integer(self.savings, input_name='savings'), namespace_, eol_))
        for buyingBlock_ in self.buyingBlock:
            buyingBlock_.export(outfile, level, namespace_, name_='buyingBlock', pretty_print=pretty_print)
        for sellingBlock_ in self.sellingBlock:
            sellingBlock_.export(outfile, level, namespace_, name_='sellingBlock', pretty_print=pretty_print)
        for rentingBlock_ in self.rentingBlock:
            rentingBlock_.export(outfile, level, namespace_, name_='rentingBlock', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'year':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'year')
            self.year = ival_
        elif nodeName_ == 'savings':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'savings')
            self.savings = ival_
        elif nodeName_ == 'buyingBlock':
            obj_ = buyingBlock.factory()
            obj_.build(child_)
            self.buyingBlock.append(obj_)
            obj_.original_tagname_ = 'buyingBlock'
        elif nodeName_ == 'sellingBlock':
            obj_ = sellingBlock.factory()
            obj_.build(child_)
            self.sellingBlock.append(obj_)
            obj_.original_tagname_ = 'sellingBlock'
        elif nodeName_ == 'rentingBlock':
            obj_ = rentingBlock.factory()
            obj_.build(child_)
            self.rentingBlock.append(obj_)
            obj_.original_tagname_ = 'rentingBlock'
# end class cumulativeYearlyCostsTable


class buyingBlock(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, buying=None):
        self.original_tagname_ = None
        if buying is None:
            self.buying = []
        else:
            self.buying = buying
    def factory(*args_, **kwargs_):
        if buyingBlock.subclass:
            return buyingBlock.subclass(*args_, **kwargs_)
        else:
            return buyingBlock(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_buying(self): return self.buying
    def set_buying(self, buying): self.buying = buying
    def add_buying(self, value): self.buying.append(value)
    def insert_buying_at(self, index, value): self.buying.insert(index, value)
    def replace_buying_at(self, index, value): self.buying[index] = value
    def hasContent_(self):
        if (
            self.buying
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='buyingBlock', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='buyingBlock')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='buyingBlock', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='buyingBlock'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='buyingBlock', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for buying_ in self.buying:
            buying_.export(outfile, level, namespace_, name_='buying', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'buying':
            obj_ = buyingType.factory()
            obj_.build(child_)
            self.buying.append(obj_)
            obj_.original_tagname_ = 'buying'
# end class buyingBlock


class rentingBlock(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, renting=None):
        self.original_tagname_ = None
        if renting is None:
            self.renting = []
        else:
            self.renting = renting
    def factory(*args_, **kwargs_):
        if rentingBlock.subclass:
            return rentingBlock.subclass(*args_, **kwargs_)
        else:
            return rentingBlock(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_renting(self): return self.renting
    def set_renting(self, renting): self.renting = renting
    def add_renting(self, value): self.renting.append(value)
    def insert_renting_at(self, index, value): self.renting.insert(index, value)
    def replace_renting_at(self, index, value): self.renting[index] = value
    def hasContent_(self):
        if (
            self.renting
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='rentingBlock', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='rentingBlock')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='rentingBlock', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='rentingBlock'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='rentingBlock', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for renting_ in self.renting:
            renting_.export(outfile, level, namespace_, name_='renting', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'renting':
            obj_ = rentingType.factory()
            obj_.build(child_)
            self.renting.append(obj_)
            obj_.original_tagname_ = 'renting'
# end class rentingBlock


class sellingBlock(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, selling=None):
        self.original_tagname_ = None
        if selling is None:
            self.selling = []
        else:
            self.selling = selling
    def factory(*args_, **kwargs_):
        if sellingBlock.subclass:
            return sellingBlock.subclass(*args_, **kwargs_)
        else:
            return sellingBlock(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_selling(self): return self.selling
    def set_selling(self, selling): self.selling = selling
    def add_selling(self, value): self.selling.append(value)
    def insert_selling_at(self, index, value): self.selling.insert(index, value)
    def replace_selling_at(self, index, value): self.selling[index] = value
    def hasContent_(self):
        if (
            self.selling
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='sellingBlock', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sellingBlock')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='sellingBlock', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='sellingBlock'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='sellingBlock', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for selling_ in self.selling:
            selling_.export(outfile, level, namespace_, name_='selling', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'selling':
            obj_ = sellingType.factory()
            obj_.build(child_)
            self.selling.append(obj_)
            obj_.original_tagname_ = 'selling'
# end class sellingBlock


class Investment(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, result=None, breakEven=None, totalProfitLoss=None, downPayment=None, closingCosts=None, InvestmentYearlyCostsTable=None, InvestmentcumulativeYearlyCostsTable=None):
        self.original_tagname_ = None
        self.result = result
        self.breakEven = breakEven
        self.totalProfitLoss = totalProfitLoss
        self.downPayment = downPayment
        self.closingCosts = closingCosts
        if InvestmentYearlyCostsTable is None:
            self.InvestmentYearlyCostsTable = []
        else:
            self.InvestmentYearlyCostsTable = InvestmentYearlyCostsTable
        if InvestmentcumulativeYearlyCostsTable is None:
            self.InvestmentcumulativeYearlyCostsTable = []
        else:
            self.InvestmentcumulativeYearlyCostsTable = InvestmentcumulativeYearlyCostsTable
    def factory(*args_, **kwargs_):
        if Investment.subclass:
            return Investment.subclass(*args_, **kwargs_)
        else:
            return Investment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_result(self): return self.result
    def set_result(self, result): self.result = result
    def get_breakEven(self): return self.breakEven
    def set_breakEven(self, breakEven): self.breakEven = breakEven
    def get_totalProfitLoss(self): return self.totalProfitLoss
    def set_totalProfitLoss(self, totalProfitLoss): self.totalProfitLoss = totalProfitLoss
    def get_downPayment(self): return self.downPayment
    def set_downPayment(self, downPayment): self.downPayment = downPayment
    def get_closingCosts(self): return self.closingCosts
    def set_closingCosts(self, closingCosts): self.closingCosts = closingCosts
    def get_InvestmentYearlyCostsTable(self): return self.InvestmentYearlyCostsTable
    def set_InvestmentYearlyCostsTable(self, InvestmentYearlyCostsTable): self.InvestmentYearlyCostsTable = InvestmentYearlyCostsTable
    def add_InvestmentYearlyCostsTable(self, value): self.InvestmentYearlyCostsTable.append(value)
    def insert_InvestmentYearlyCostsTable_at(self, index, value): self.InvestmentYearlyCostsTable.insert(index, value)
    def replace_InvestmentYearlyCostsTable_at(self, index, value): self.InvestmentYearlyCostsTable[index] = value
    def get_InvestmentcumulativeYearlyCostsTable(self): return self.InvestmentcumulativeYearlyCostsTable
    def set_InvestmentcumulativeYearlyCostsTable(self, InvestmentcumulativeYearlyCostsTable): self.InvestmentcumulativeYearlyCostsTable = InvestmentcumulativeYearlyCostsTable
    def add_InvestmentcumulativeYearlyCostsTable(self, value): self.InvestmentcumulativeYearlyCostsTable.append(value)
    def insert_InvestmentcumulativeYearlyCostsTable_at(self, index, value): self.InvestmentcumulativeYearlyCostsTable.insert(index, value)
    def replace_InvestmentcumulativeYearlyCostsTable_at(self, index, value): self.InvestmentcumulativeYearlyCostsTable[index] = value
    def hasContent_(self):
        if (
            self.result is not None or
            self.breakEven is not None or
            self.totalProfitLoss is not None or
            self.downPayment is not None or
            self.closingCosts is not None or
            self.InvestmentYearlyCostsTable or
            self.InvestmentcumulativeYearlyCostsTable
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='Investment', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Investment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='Investment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='Investment'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='Investment', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.result is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sresult>%s</%sresult>%s' % (namespace_, self.gds_format_string(quote_xml(self.result).encode(ExternalEncoding), input_name='result'), namespace_, eol_))
        if self.breakEven is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbreakEven>%s</%sbreakEven>%s' % (namespace_, self.gds_format_integer(self.breakEven, input_name='breakEven'), namespace_, eol_))
        if self.totalProfitLoss is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalProfitLoss>%s</%stotalProfitLoss>%s' % (namespace_, self.gds_format_integer(self.totalProfitLoss, input_name='totalProfitLoss'), namespace_, eol_))
        if self.downPayment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdownPayment>%s</%sdownPayment>%s' % (namespace_, self.gds_format_integer(self.downPayment, input_name='downPayment'), namespace_, eol_))
        if self.closingCosts is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sclosingCosts>%s</%sclosingCosts>%s' % (namespace_, self.gds_format_integer(self.closingCosts, input_name='closingCosts'), namespace_, eol_))
        for InvestmentYearlyCostsTable_ in self.InvestmentYearlyCostsTable:
            InvestmentYearlyCostsTable_.export(outfile, level, namespace_, name_='InvestmentYearlyCostsTable', pretty_print=pretty_print)
        for InvestmentcumulativeYearlyCostsTable_ in self.InvestmentcumulativeYearlyCostsTable:
            InvestmentcumulativeYearlyCostsTable_.export(outfile, level, namespace_, name_='InvestmentcumulativeYearlyCostsTable', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'result':
            result_ = child_.text
            result_ = self.gds_validate_string(result_, node, 'result')
            self.result = result_
        elif nodeName_ == 'breakEven':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'breakEven')
            self.breakEven = ival_
        elif nodeName_ == 'totalProfitLoss':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'totalProfitLoss')
            self.totalProfitLoss = ival_
        elif nodeName_ == 'downPayment':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'downPayment')
            self.downPayment = ival_
        elif nodeName_ == 'closingCosts':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'closingCosts')
            self.closingCosts = ival_
        elif nodeName_ == 'InvestmentYearlyCostsTable':
            obj_ = investmentYearlyCostsTable.factory()
            obj_.build(child_)
            self.InvestmentYearlyCostsTable.append(obj_)
            obj_.original_tagname_ = 'InvestmentYearlyCostsTable'
        elif nodeName_ == 'InvestmentcumulativeYearlyCostsTable':
            obj_ = investmentCumulativeYearlyCostsTable.factory()
            obj_.build(child_)
            self.InvestmentcumulativeYearlyCostsTable.append(obj_)
            obj_.original_tagname_ = 'InvestmentcumulativeYearlyCostsTable'
# end class Investment


class investmentYearlyCostsTable(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, investmentBuyingBlock=None):
        self.original_tagname_ = None
        if investmentBuyingBlock is None:
            self.investmentBuyingBlock = []
        else:
            self.investmentBuyingBlock = investmentBuyingBlock
    def factory(*args_, **kwargs_):
        if investmentYearlyCostsTable.subclass:
            return investmentYearlyCostsTable.subclass(*args_, **kwargs_)
        else:
            return investmentYearlyCostsTable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_investmentBuyingBlock(self): return self.investmentBuyingBlock
    def set_investmentBuyingBlock(self, investmentBuyingBlock): self.investmentBuyingBlock = investmentBuyingBlock
    def add_investmentBuyingBlock(self, value): self.investmentBuyingBlock.append(value)
    def insert_investmentBuyingBlock_at(self, index, value): self.investmentBuyingBlock.insert(index, value)
    def replace_investmentBuyingBlock_at(self, index, value): self.investmentBuyingBlock[index] = value
    def hasContent_(self):
        if (
            self.investmentBuyingBlock
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='investmentYearlyCostsTable', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='investmentYearlyCostsTable')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='investmentYearlyCostsTable', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='investmentYearlyCostsTable'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='investmentYearlyCostsTable', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for investmentBuyingBlock_ in self.investmentBuyingBlock:
            investmentBuyingBlock_.export(outfile, level, namespace_, name_='investmentBuyingBlock', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'investmentBuyingBlock':
            obj_ = investmentBuyingBlock.factory()
            obj_.build(child_)
            self.investmentBuyingBlock.append(obj_)
            obj_.original_tagname_ = 'investmentBuyingBlock'
# end class investmentYearlyCostsTable


class investmentCumulativeYearlyCostsTable(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, investmentBuyingBlock=None, sellingBlock=None, investmentreturn=None):
        self.original_tagname_ = None
        if investmentBuyingBlock is None:
            self.investmentBuyingBlock = []
        else:
            self.investmentBuyingBlock = investmentBuyingBlock
        if sellingBlock is None:
            self.sellingBlock = []
        else:
            self.sellingBlock = sellingBlock
        self.investmentreturn = investmentreturn
    def factory(*args_, **kwargs_):
        if investmentCumulativeYearlyCostsTable.subclass:
            return investmentCumulativeYearlyCostsTable.subclass(*args_, **kwargs_)
        else:
            return investmentCumulativeYearlyCostsTable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_investmentBuyingBlock(self): return self.investmentBuyingBlock
    def set_investmentBuyingBlock(self, investmentBuyingBlock): self.investmentBuyingBlock = investmentBuyingBlock
    def add_investmentBuyingBlock(self, value): self.investmentBuyingBlock.append(value)
    def insert_investmentBuyingBlock_at(self, index, value): self.investmentBuyingBlock.insert(index, value)
    def replace_investmentBuyingBlock_at(self, index, value): self.investmentBuyingBlock[index] = value
    def get_sellingBlock(self): return self.sellingBlock
    def set_sellingBlock(self, sellingBlock): self.sellingBlock = sellingBlock
    def add_sellingBlock(self, value): self.sellingBlock.append(value)
    def insert_sellingBlock_at(self, index, value): self.sellingBlock.insert(index, value)
    def replace_sellingBlock_at(self, index, value): self.sellingBlock[index] = value
    def get_investmentreturn(self): return self.investmentreturn
    def set_investmentreturn(self, investmentreturn): self.investmentreturn = investmentreturn
    def hasContent_(self):
        if (
            self.investmentBuyingBlock or
            self.sellingBlock or
            self.investmentreturn is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='investmentCumulativeYearlyCostsTable', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='investmentCumulativeYearlyCostsTable')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='investmentCumulativeYearlyCostsTable', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='investmentCumulativeYearlyCostsTable'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='investmentCumulativeYearlyCostsTable', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for investmentBuyingBlock_ in self.investmentBuyingBlock:
            investmentBuyingBlock_.export(outfile, level, namespace_, name_='investmentBuyingBlock', pretty_print=pretty_print)
        for sellingBlock_ in self.sellingBlock:
            sellingBlock_.export(outfile, level, namespace_, name_='sellingBlock', pretty_print=pretty_print)
        if self.investmentreturn is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvestmentreturn>%s</%sinvestmentreturn>%s' % (namespace_, self.gds_format_double(self.investmentreturn, input_name='investmentreturn'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'investmentBuyingBlock':
            obj_ = investmentBuyingBlock.factory()
            obj_.build(child_)
            self.investmentBuyingBlock.append(obj_)
            obj_.original_tagname_ = 'investmentBuyingBlock'
        elif nodeName_ == 'sellingBlock':
            obj_ = sellingBlock.factory()
            obj_.build(child_)
            self.sellingBlock.append(obj_)
            obj_.original_tagname_ = 'sellingBlock'
        elif nodeName_ == 'investmentreturn':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'investmentreturn')
            self.investmentreturn = fval_
# end class investmentCumulativeYearlyCostsTable


class investmentBuyingBlock(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, buying=None):
        self.original_tagname_ = None
        if buying is None:
            self.buying = []
        else:
            self.buying = buying
    def factory(*args_, **kwargs_):
        if investmentBuyingBlock.subclass:
            return investmentBuyingBlock.subclass(*args_, **kwargs_)
        else:
            return investmentBuyingBlock(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_buying(self): return self.buying
    def set_buying(self, buying): self.buying = buying
    def add_buying(self, value): self.buying.append(value)
    def insert_buying_at(self, index, value): self.buying.insert(index, value)
    def replace_buying_at(self, index, value): self.buying[index] = value
    def hasContent_(self):
        if (
            self.buying
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='investmentBuyingBlock', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='investmentBuyingBlock')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='investmentBuyingBlock', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='investmentBuyingBlock'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='investmentBuyingBlock', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for buying_ in self.buying:
            buying_.export(outfile, level, namespace_, name_='buying', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'buying':
            obj_ = buying.factory()
            obj_.build(child_)
            self.buying.append(obj_)
            obj_.original_tagname_ = 'buying'
# end class investmentBuyingBlock


class buying(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, year=None, rentalIncome=None, otherIncome=None, mortgagePayment=None, principal=None, interest=None, hoaFees=None, propertyTaxes=None, utilities=None, renovations=None, maintainCosts=None, homeOwnerInsurance=None, managementFees=None, advertisingCosts=None, otherExpenses=None, totalExpenses=None, opportunityCostInitial=None, opportunityCostYearly=None, depreciationBuilding=None, depreciationrenovation=None, totalBenefit=None, totalProfitLoss=None):
        self.original_tagname_ = None
        self.year = year
        self.rentalIncome = rentalIncome
        self.otherIncome = otherIncome
        self.mortgagePayment = mortgagePayment
        self.principal = principal
        self.interest = interest
        self.hoaFees = hoaFees
        self.propertyTaxes = propertyTaxes
        self.utilities = utilities
        self.renovations = renovations
        self.maintainCosts = maintainCosts
        self.homeOwnerInsurance = homeOwnerInsurance
        self.managementFees = managementFees
        self.advertisingCosts = advertisingCosts
        self.otherExpenses = otherExpenses
        self.totalExpenses = totalExpenses
        self.opportunityCostInitial = opportunityCostInitial
        self.opportunityCostYearly = opportunityCostYearly
        self.depreciationBuilding = depreciationBuilding
        self.depreciationrenovation = depreciationrenovation
        self.totalBenefit = totalBenefit
        self.totalProfitLoss = totalProfitLoss
    def factory(*args_, **kwargs_):
        if buying.subclass:
            return buying.subclass(*args_, **kwargs_)
        else:
            return buying(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_year(self): return self.year
    def set_year(self, year): self.year = year
    def get_rentalIncome(self): return self.rentalIncome
    def set_rentalIncome(self, rentalIncome): self.rentalIncome = rentalIncome
    def get_otherIncome(self): return self.otherIncome
    def set_otherIncome(self, otherIncome): self.otherIncome = otherIncome
    def get_mortgagePayment(self): return self.mortgagePayment
    def set_mortgagePayment(self, mortgagePayment): self.mortgagePayment = mortgagePayment
    def get_principal(self): return self.principal
    def set_principal(self, principal): self.principal = principal
    def get_interest(self): return self.interest
    def set_interest(self, interest): self.interest = interest
    def get_hoaFees(self): return self.hoaFees
    def set_hoaFees(self, hoaFees): self.hoaFees = hoaFees
    def get_propertyTaxes(self): return self.propertyTaxes
    def set_propertyTaxes(self, propertyTaxes): self.propertyTaxes = propertyTaxes
    def get_utilities(self): return self.utilities
    def set_utilities(self, utilities): self.utilities = utilities
    def get_renovations(self): return self.renovations
    def set_renovations(self, renovations): self.renovations = renovations
    def get_maintainCosts(self): return self.maintainCosts
    def set_maintainCosts(self, maintainCosts): self.maintainCosts = maintainCosts
    def get_homeOwnerInsurance(self): return self.homeOwnerInsurance
    def set_homeOwnerInsurance(self, homeOwnerInsurance): self.homeOwnerInsurance = homeOwnerInsurance
    def get_managementFees(self): return self.managementFees
    def set_managementFees(self, managementFees): self.managementFees = managementFees
    def get_advertisingCosts(self): return self.advertisingCosts
    def set_advertisingCosts(self, advertisingCosts): self.advertisingCosts = advertisingCosts
    def get_otherExpenses(self): return self.otherExpenses
    def set_otherExpenses(self, otherExpenses): self.otherExpenses = otherExpenses
    def get_totalExpenses(self): return self.totalExpenses
    def set_totalExpenses(self, totalExpenses): self.totalExpenses = totalExpenses
    def get_opportunityCostInitial(self): return self.opportunityCostInitial
    def set_opportunityCostInitial(self, opportunityCostInitial): self.opportunityCostInitial = opportunityCostInitial
    def get_opportunityCostYearly(self): return self.opportunityCostYearly
    def set_opportunityCostYearly(self, opportunityCostYearly): self.opportunityCostYearly = opportunityCostYearly
    def get_depreciationBuilding(self): return self.depreciationBuilding
    def set_depreciationBuilding(self, depreciationBuilding): self.depreciationBuilding = depreciationBuilding
    def get_depreciationrenovation(self): return self.depreciationrenovation
    def set_depreciationrenovation(self, depreciationrenovation): self.depreciationrenovation = depreciationrenovation
    def get_totalBenefit(self): return self.totalBenefit
    def set_totalBenefit(self, totalBenefit): self.totalBenefit = totalBenefit
    def get_totalProfitLoss(self): return self.totalProfitLoss
    def set_totalProfitLoss(self, totalProfitLoss): self.totalProfitLoss = totalProfitLoss
    def hasContent_(self):
        if (
            self.year is not None or
            self.rentalIncome is not None or
            self.otherIncome is not None or
            self.mortgagePayment is not None or
            self.principal is not None or
            self.interest is not None or
            self.hoaFees is not None or
            self.propertyTaxes is not None or
            self.utilities is not None or
            self.renovations is not None or
            self.maintainCosts is not None or
            self.homeOwnerInsurance is not None or
            self.managementFees is not None or
            self.advertisingCosts is not None or
            self.otherExpenses is not None or
            self.totalExpenses is not None or
            self.opportunityCostInitial is not None or
            self.opportunityCostYearly is not None or
            self.depreciationBuilding is not None or
            self.depreciationrenovation is not None or
            self.totalBenefit is not None or
            self.totalProfitLoss is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='buying', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='buying')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='buying', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='buying'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='buying', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.year is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%syear>%s</%syear>%s' % (namespace_, self.gds_format_integer(self.year, input_name='year'), namespace_, eol_))
        if self.rentalIncome is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srentalIncome>%s</%srentalIncome>%s' % (namespace_, self.gds_format_integer(self.rentalIncome, input_name='rentalIncome'), namespace_, eol_))
        if self.otherIncome is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sotherIncome>%s</%sotherIncome>%s' % (namespace_, self.gds_format_integer(self.otherIncome, input_name='otherIncome'), namespace_, eol_))
        if self.mortgagePayment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smortgagePayment>%s</%smortgagePayment>%s' % (namespace_, self.gds_format_integer(self.mortgagePayment, input_name='mortgagePayment'), namespace_, eol_))
        if self.principal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprincipal>%s</%sprincipal>%s' % (namespace_, self.gds_format_integer(self.principal, input_name='principal'), namespace_, eol_))
        if self.interest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinterest>%s</%sinterest>%s' % (namespace_, self.gds_format_integer(self.interest, input_name='interest'), namespace_, eol_))
        if self.hoaFees is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shoaFees>%s</%shoaFees>%s' % (namespace_, self.gds_format_integer(self.hoaFees, input_name='hoaFees'), namespace_, eol_))
        if self.propertyTaxes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spropertyTaxes>%s</%spropertyTaxes>%s' % (namespace_, self.gds_format_integer(self.propertyTaxes, input_name='propertyTaxes'), namespace_, eol_))
        if self.utilities is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sutilities>%s</%sutilities>%s' % (namespace_, self.gds_format_integer(self.utilities, input_name='utilities'), namespace_, eol_))
        if self.renovations is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srenovations>%s</%srenovations>%s' % (namespace_, self.gds_format_integer(self.renovations, input_name='renovations'), namespace_, eol_))
        if self.maintainCosts is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaintainCosts>%s</%smaintainCosts>%s' % (namespace_, self.gds_format_integer(self.maintainCosts, input_name='maintainCosts'), namespace_, eol_))
        if self.homeOwnerInsurance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shomeOwnerInsurance>%s</%shomeOwnerInsurance>%s' % (namespace_, self.gds_format_integer(self.homeOwnerInsurance, input_name='homeOwnerInsurance'), namespace_, eol_))
        if self.managementFees is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smanagementFees>%s</%smanagementFees>%s' % (namespace_, self.gds_format_integer(self.managementFees, input_name='managementFees'), namespace_, eol_))
        if self.advertisingCosts is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sadvertisingCosts>%s</%sadvertisingCosts>%s' % (namespace_, self.gds_format_integer(self.advertisingCosts, input_name='advertisingCosts'), namespace_, eol_))
        if self.otherExpenses is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sotherExpenses>%s</%sotherExpenses>%s' % (namespace_, self.gds_format_integer(self.otherExpenses, input_name='otherExpenses'), namespace_, eol_))
        if self.totalExpenses is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalExpenses>%s</%stotalExpenses>%s' % (namespace_, self.gds_format_integer(self.totalExpenses, input_name='totalExpenses'), namespace_, eol_))
        if self.opportunityCostInitial is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sopportunityCostInitial>%s</%sopportunityCostInitial>%s' % (namespace_, self.gds_format_integer(self.opportunityCostInitial, input_name='opportunityCostInitial'), namespace_, eol_))
        if self.opportunityCostYearly is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sopportunityCostYearly>%s</%sopportunityCostYearly>%s' % (namespace_, self.gds_format_integer(self.opportunityCostYearly, input_name='opportunityCostYearly'), namespace_, eol_))
        if self.depreciationBuilding is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdepreciationBuilding>%s</%sdepreciationBuilding>%s' % (namespace_, self.gds_format_integer(self.depreciationBuilding, input_name='depreciationBuilding'), namespace_, eol_))
        if self.depreciationrenovation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdepreciationrenovation>%s</%sdepreciationrenovation>%s' % (namespace_, self.gds_format_integer(self.depreciationrenovation, input_name='depreciationrenovation'), namespace_, eol_))
        if self.totalBenefit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalBenefit>%s</%stotalBenefit>%s' % (namespace_, self.gds_format_integer(self.totalBenefit, input_name='totalBenefit'), namespace_, eol_))
        if self.totalProfitLoss is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalProfitLoss>%s</%stotalProfitLoss>%s' % (namespace_, self.gds_format_integer(self.totalProfitLoss, input_name='totalProfitLoss'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'year':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'year')
            self.year = ival_
        elif nodeName_ == 'rentalIncome':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'rentalIncome')
            self.rentalIncome = ival_
        elif nodeName_ == 'otherIncome':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'otherIncome')
            self.otherIncome = ival_
        elif nodeName_ == 'mortgagePayment':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'mortgagePayment')
            self.mortgagePayment = ival_
        elif nodeName_ == 'principal':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'principal')
            self.principal = ival_
        elif nodeName_ == 'interest':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'interest')
            self.interest = ival_
        elif nodeName_ == 'hoaFees':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'hoaFees')
            self.hoaFees = ival_
        elif nodeName_ == 'propertyTaxes':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'propertyTaxes')
            self.propertyTaxes = ival_
        elif nodeName_ == 'utilities':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'utilities')
            self.utilities = ival_
        elif nodeName_ == 'renovations':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'renovations')
            self.renovations = ival_
        elif nodeName_ == 'maintainCosts':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'maintainCosts')
            self.maintainCosts = ival_
        elif nodeName_ == 'homeOwnerInsurance':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'homeOwnerInsurance')
            self.homeOwnerInsurance = ival_
        elif nodeName_ == 'managementFees':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'managementFees')
            self.managementFees = ival_
        elif nodeName_ == 'advertisingCosts':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'advertisingCosts')
            self.advertisingCosts = ival_
        elif nodeName_ == 'otherExpenses':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'otherExpenses')
            self.otherExpenses = ival_
        elif nodeName_ == 'totalExpenses':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'totalExpenses')
            self.totalExpenses = ival_
        elif nodeName_ == 'opportunityCostInitial':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'opportunityCostInitial')
            self.opportunityCostInitial = ival_
        elif nodeName_ == 'opportunityCostYearly':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'opportunityCostYearly')
            self.opportunityCostYearly = ival_
        elif nodeName_ == 'depreciationBuilding':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'depreciationBuilding')
            self.depreciationBuilding = ival_
        elif nodeName_ == 'depreciationrenovation':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'depreciationrenovation')
            self.depreciationrenovation = ival_
        elif nodeName_ == 'totalBenefit':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'totalBenefit')
            self.totalBenefit = ival_
        elif nodeName_ == 'totalProfitLoss':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'totalProfitLoss')
            self.totalProfitLoss = ival_
# end class buying


class valuationRangeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, low=None, high=None):
        self.original_tagname_ = None
        self.low = low
        self.high = high
    def factory(*args_, **kwargs_):
        if valuationRangeType.subclass:
            return valuationRangeType.subclass(*args_, **kwargs_)
        else:
            return valuationRangeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_low(self): return self.low
    def set_low(self, low): self.low = low
    def get_high(self): return self.high
    def set_high(self, high): self.high = high
    def hasContent_(self):
        if (
            self.low is not None or
            self.high is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='valuationRangeType', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='valuationRangeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='valuationRangeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='valuationRangeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='valuationRangeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.low is not None:
            self.low.export(outfile, level, namespace_, name_='low', pretty_print=pretty_print)
        if self.high is not None:
            self.high.export(outfile, level, namespace_, name_='high', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'low':
            obj_ = Amount.factory()
            obj_.build(child_)
            self.low = obj_
            obj_.original_tagname_ = 'low'
        elif nodeName_ == 'high':
            obj_ = Amount.factory()
            obj_.build(child_)
            self.high = obj_
            obj_.original_tagname_ = 'high'
# end class valuationRangeType


class valuationRangeType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, low=None, high=None):
        self.original_tagname_ = None
        self.low = low
        self.high = high
    def factory(*args_, **kwargs_):
        if valuationRangeType1.subclass:
            return valuationRangeType1.subclass(*args_, **kwargs_)
        else:
            return valuationRangeType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_low(self): return self.low
    def set_low(self, low): self.low = low
    def get_high(self): return self.high
    def set_high(self, high): self.high = high
    def hasContent_(self):
        if (
            self.low is not None or
            self.high is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='valuationRangeType1', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='valuationRangeType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='valuationRangeType1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='valuationRangeType1'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='valuationRangeType1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.low is not None:
            self.low.export(outfile, level, namespace_, name_='low', pretty_print=pretty_print)
        if self.high is not None:
            self.high.export(outfile, level, namespace_, name_='high', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'low':
            obj_ = Amount.factory()
            obj_.build(child_)
            self.low = obj_
            obj_.original_tagname_ = 'low'
        elif nodeName_ == 'high':
            obj_ = Amount.factory()
            obj_.build(child_)
            self.high = obj_
            obj_.original_tagname_ = 'high'
# end class valuationRangeType1


class regionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, name=None, id=None, zindexValue=None, zindexOneYearChange=None, links=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.name = _cast(None, name)
        self.id = _cast(int, id)
        self.zindexValue = zindexValue
        self.zindexOneYearChange = zindexOneYearChange
        self.links = links
    def factory(*args_, **kwargs_):
        if regionType.subclass:
            return regionType.subclass(*args_, **kwargs_)
        else:
            return regionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_zindexValue(self): return self.zindexValue
    def set_zindexValue(self, zindexValue): self.zindexValue = zindexValue
    def get_zindexOneYearChange(self): return self.zindexOneYearChange
    def set_zindexOneYearChange(self, zindexOneYearChange): self.zindexOneYearChange = zindexOneYearChange
    def get_links(self): return self.links
    def set_links(self, links): self.links = links
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.zindexValue is not None or
            self.zindexOneYearChange is not None or
            self.links is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='regionType', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='regionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='regionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='regionType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='regionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.zindexValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%szindexValue>%s</%szindexValue>%s' % (namespace_, self.gds_format_string(quote_xml(self.zindexValue).encode(ExternalEncoding), input_name='zindexValue'), namespace_, eol_))
        if self.zindexOneYearChange is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%szindexOneYearChange>%s</%szindexOneYearChange>%s' % (namespace_, self.gds_format_string(quote_xml(self.zindexOneYearChange).encode(ExternalEncoding), input_name='zindexOneYearChange'), namespace_, eol_))
        if self.links is not None:
            self.links.export(outfile, level, namespace_, name_='links', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            try:
                self.id = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'zindexValue':
            zindexValue_ = child_.text
            zindexValue_ = self.gds_validate_string(zindexValue_, node, 'zindexValue')
            self.zindexValue = zindexValue_
        elif nodeName_ == 'zindexOneYearChange':
            zindexOneYearChange_ = child_.text
            zindexOneYearChange_ = self.gds_validate_string(zindexOneYearChange_, node, 'zindexOneYearChange')
            self.zindexOneYearChange = zindexOneYearChange_
        elif nodeName_ == 'links':
            obj_ = linksType.factory()
            obj_.build(child_)
            self.links = obj_
            obj_.original_tagname_ = 'links'
# end class regionType


class linksType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, overview=None, forSaleByOwner=None, forSale=None):
        self.original_tagname_ = None
        self.overview = overview
        self.forSaleByOwner = forSaleByOwner
        self.forSale = forSale
    def factory(*args_, **kwargs_):
        if linksType.subclass:
            return linksType.subclass(*args_, **kwargs_)
        else:
            return linksType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_overview(self): return self.overview
    def set_overview(self, overview): self.overview = overview
    def get_forSaleByOwner(self): return self.forSaleByOwner
    def set_forSaleByOwner(self, forSaleByOwner): self.forSaleByOwner = forSaleByOwner
    def get_forSale(self): return self.forSale
    def set_forSale(self, forSale): self.forSale = forSale
    def hasContent_(self):
        if (
            self.overview is not None or
            self.forSaleByOwner is not None or
            self.forSale is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='linksType', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='linksType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='linksType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='linksType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='linksType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.overview is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soverview>%s</%soverview>%s' % (namespace_, self.gds_format_string(quote_xml(self.overview).encode(ExternalEncoding), input_name='overview'), namespace_, eol_))
        if self.forSaleByOwner is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sforSaleByOwner>%s</%sforSaleByOwner>%s' % (namespace_, self.gds_format_string(quote_xml(self.forSaleByOwner).encode(ExternalEncoding), input_name='forSaleByOwner'), namespace_, eol_))
        if self.forSale is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sforSale>%s</%sforSale>%s' % (namespace_, self.gds_format_string(quote_xml(self.forSale).encode(ExternalEncoding), input_name='forSale'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'overview':
            overview_ = child_.text
            overview_ = self.gds_validate_string(overview_, node, 'overview')
            self.overview = overview_
        elif nodeName_ == 'forSaleByOwner':
            forSaleByOwner_ = child_.text
            forSaleByOwner_ = self.gds_validate_string(forSaleByOwner_, node, 'forSaleByOwner')
            self.forSaleByOwner = forSaleByOwner_
        elif nodeName_ == 'forSale':
            forSale_ = child_.text
            forSale_ = self.gds_validate_string(forSale_, node, 'forSale')
            self.forSale = forSale_
# end class linksType


class paymentType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, beginningBalance=None, amount=None, principal=None, interest=None, endingBalance=None):
        self.original_tagname_ = None
        self.beginningBalance = beginningBalance
        self.amount = amount
        self.principal = principal
        self.interest = interest
        self.endingBalance = endingBalance
    def factory(*args_, **kwargs_):
        if paymentType.subclass:
            return paymentType.subclass(*args_, **kwargs_)
        else:
            return paymentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_beginningBalance(self): return self.beginningBalance
    def set_beginningBalance(self, beginningBalance): self.beginningBalance = beginningBalance
    def get_amount(self): return self.amount
    def set_amount(self, amount): self.amount = amount
    def get_principal(self): return self.principal
    def set_principal(self, principal): self.principal = principal
    def get_interest(self): return self.interest
    def set_interest(self, interest): self.interest = interest
    def get_endingBalance(self): return self.endingBalance
    def set_endingBalance(self, endingBalance): self.endingBalance = endingBalance
    def hasContent_(self):
        if (
            self.beginningBalance is not None or
            self.amount is not None or
            self.principal is not None or
            self.interest is not None or
            self.endingBalance is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='paymentType', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='paymentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='paymentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='paymentType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='paymentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.beginningBalance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbeginningBalance>%s</%sbeginningBalance>%s' % (namespace_, self.gds_format_integer(self.beginningBalance, input_name='beginningBalance'), namespace_, eol_))
        if self.amount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%samount>%s</%samount>%s' % (namespace_, self.gds_format_integer(self.amount, input_name='amount'), namespace_, eol_))
        if self.principal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprincipal>%s</%sprincipal>%s' % (namespace_, self.gds_format_integer(self.principal, input_name='principal'), namespace_, eol_))
        if self.interest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinterest>%s</%sinterest>%s' % (namespace_, self.gds_format_integer(self.interest, input_name='interest'), namespace_, eol_))
        if self.endingBalance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sendingBalance>%s</%sendingBalance>%s' % (namespace_, self.gds_format_integer(self.endingBalance, input_name='endingBalance'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'beginningBalance':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'beginningBalance')
            self.beginningBalance = ival_
        elif nodeName_ == 'amount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'amount')
            self.amount = ival_
        elif nodeName_ == 'principal':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'principal')
            self.principal = ival_
        elif nodeName_ == 'interest':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'interest')
            self.interest = ival_
        elif nodeName_ == 'endingBalance':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'endingBalance')
            self.endingBalance = ival_
# end class paymentType


class paymentType2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, period=None, monthlySavings=None, cumulativeSavings=None, endingBalance=None):
        self.original_tagname_ = None
        self.period = period
        self.monthlySavings = monthlySavings
        self.cumulativeSavings = cumulativeSavings
        self.endingBalance = endingBalance
    def factory(*args_, **kwargs_):
        if paymentType2.subclass:
            return paymentType2.subclass(*args_, **kwargs_)
        else:
            return paymentType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_period(self): return self.period
    def set_period(self, period): self.period = period
    def get_monthlySavings(self): return self.monthlySavings
    def set_monthlySavings(self, monthlySavings): self.monthlySavings = monthlySavings
    def get_cumulativeSavings(self): return self.cumulativeSavings
    def set_cumulativeSavings(self, cumulativeSavings): self.cumulativeSavings = cumulativeSavings
    def get_endingBalance(self): return self.endingBalance
    def set_endingBalance(self, endingBalance): self.endingBalance = endingBalance
    def hasContent_(self):
        if (
            self.period is not None or
            self.monthlySavings is not None or
            self.cumulativeSavings is not None or
            self.endingBalance is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='paymentType2', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='paymentType2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='paymentType2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='paymentType2'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='paymentType2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.period is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%speriod>%s</%speriod>%s' % (namespace_, self.gds_format_integer(self.period, input_name='period'), namespace_, eol_))
        if self.monthlySavings is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smonthlySavings>%s</%smonthlySavings>%s' % (namespace_, self.gds_format_integer(self.monthlySavings, input_name='monthlySavings'), namespace_, eol_))
        if self.cumulativeSavings is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scumulativeSavings>%s</%scumulativeSavings>%s' % (namespace_, self.gds_format_integer(self.cumulativeSavings, input_name='cumulativeSavings'), namespace_, eol_))
        if self.endingBalance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sendingBalance>%s</%sendingBalance>%s' % (namespace_, self.gds_format_integer(self.endingBalance, input_name='endingBalance'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'period':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'period')
            self.period = ival_
        elif nodeName_ == 'monthlySavings':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'monthlySavings')
            self.monthlySavings = ival_
        elif nodeName_ == 'cumulativeSavings':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'cumulativeSavings')
            self.cumulativeSavings = ival_
        elif nodeName_ == 'endingBalance':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'endingBalance')
            self.endingBalance = ival_
# end class paymentType2


class PaymentType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, period=None, fixedPayment=None, fixedBalance=None, adjustablePayment=None, adjustableBalance=None, adjustableRate=None):
        self.original_tagname_ = None
        self.period = period
        self.fixedPayment = fixedPayment
        self.fixedBalance = fixedBalance
        self.adjustablePayment = adjustablePayment
        self.adjustableBalance = adjustableBalance
        self.adjustableRate = adjustableRate
    def factory(*args_, **kwargs_):
        if PaymentType.subclass:
            return PaymentType.subclass(*args_, **kwargs_)
        else:
            return PaymentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_period(self): return self.period
    def set_period(self, period): self.period = period
    def get_fixedPayment(self): return self.fixedPayment
    def set_fixedPayment(self, fixedPayment): self.fixedPayment = fixedPayment
    def get_fixedBalance(self): return self.fixedBalance
    def set_fixedBalance(self, fixedBalance): self.fixedBalance = fixedBalance
    def get_adjustablePayment(self): return self.adjustablePayment
    def set_adjustablePayment(self, adjustablePayment): self.adjustablePayment = adjustablePayment
    def get_adjustableBalance(self): return self.adjustableBalance
    def set_adjustableBalance(self, adjustableBalance): self.adjustableBalance = adjustableBalance
    def get_adjustableRate(self): return self.adjustableRate
    def set_adjustableRate(self, adjustableRate): self.adjustableRate = adjustableRate
    def hasContent_(self):
        if (
            self.period is not None or
            self.fixedPayment is not None or
            self.fixedBalance is not None or
            self.adjustablePayment is not None or
            self.adjustableBalance is not None or
            self.adjustableRate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='PaymentType', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='PaymentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='PaymentType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='PaymentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.period is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%speriod>%s</%speriod>%s' % (namespace_, self.gds_format_integer(self.period, input_name='period'), namespace_, eol_))
        if self.fixedPayment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfixedPayment>%s</%sfixedPayment>%s' % (namespace_, self.gds_format_integer(self.fixedPayment, input_name='fixedPayment'), namespace_, eol_))
        if self.fixedBalance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfixedBalance>%s</%sfixedBalance>%s' % (namespace_, self.gds_format_integer(self.fixedBalance, input_name='fixedBalance'), namespace_, eol_))
        if self.adjustablePayment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sadjustablePayment>%s</%sadjustablePayment>%s' % (namespace_, self.gds_format_integer(self.adjustablePayment, input_name='adjustablePayment'), namespace_, eol_))
        if self.adjustableBalance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sadjustableBalance>%s</%sadjustableBalance>%s' % (namespace_, self.gds_format_integer(self.adjustableBalance, input_name='adjustableBalance'), namespace_, eol_))
        if self.adjustableRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sadjustableRate>%s</%sadjustableRate>%s' % (namespace_, self.gds_format_integer(self.adjustableRate, input_name='adjustableRate'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'period':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'period')
            self.period = ival_
        elif nodeName_ == 'fixedPayment':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'fixedPayment')
            self.fixedPayment = ival_
        elif nodeName_ == 'fixedBalance':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'fixedBalance')
            self.fixedBalance = ival_
        elif nodeName_ == 'adjustablePayment':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'adjustablePayment')
            self.adjustablePayment = ival_
        elif nodeName_ == 'adjustableBalance':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'adjustableBalance')
            self.adjustableBalance = ival_
        elif nodeName_ == 'adjustableRate':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'adjustableRate')
            self.adjustableRate = ival_
# end class PaymentType


class PaymentType3(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, period=None, beginningBalance=None, payment=None, principal=None, interest=None, endingBalance=None, rate=None):
        self.original_tagname_ = None
        self.period = period
        self.beginningBalance = beginningBalance
        self.payment = payment
        self.principal = principal
        self.interest = interest
        self.endingBalance = endingBalance
        self.rate = rate
    def factory(*args_, **kwargs_):
        if PaymentType3.subclass:
            return PaymentType3.subclass(*args_, **kwargs_)
        else:
            return PaymentType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_period(self): return self.period
    def set_period(self, period): self.period = period
    def get_beginningBalance(self): return self.beginningBalance
    def set_beginningBalance(self, beginningBalance): self.beginningBalance = beginningBalance
    def get_payment(self): return self.payment
    def set_payment(self, payment): self.payment = payment
    def get_principal(self): return self.principal
    def set_principal(self, principal): self.principal = principal
    def get_interest(self): return self.interest
    def set_interest(self, interest): self.interest = interest
    def get_endingBalance(self): return self.endingBalance
    def set_endingBalance(self, endingBalance): self.endingBalance = endingBalance
    def get_rate(self): return self.rate
    def set_rate(self, rate): self.rate = rate
    def hasContent_(self):
        if (
            self.period is not None or
            self.beginningBalance is not None or
            self.payment is not None or
            self.principal is not None or
            self.interest is not None or
            self.endingBalance is not None or
            self.rate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='PaymentType3', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentType3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='PaymentType3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='PaymentType3'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='PaymentType3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.period is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%speriod>%s</%speriod>%s' % (namespace_, self.gds_format_integer(self.period, input_name='period'), namespace_, eol_))
        if self.beginningBalance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbeginningBalance>%s</%sbeginningBalance>%s' % (namespace_, self.gds_format_integer(self.beginningBalance, input_name='beginningBalance'), namespace_, eol_))
        if self.payment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spayment>%s</%spayment>%s' % (namespace_, self.gds_format_integer(self.payment, input_name='payment'), namespace_, eol_))
        if self.principal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprincipal>%s</%sprincipal>%s' % (namespace_, self.gds_format_integer(self.principal, input_name='principal'), namespace_, eol_))
        if self.interest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinterest>%s</%sinterest>%s' % (namespace_, self.gds_format_integer(self.interest, input_name='interest'), namespace_, eol_))
        if self.endingBalance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sendingBalance>%s</%sendingBalance>%s' % (namespace_, self.gds_format_integer(self.endingBalance, input_name='endingBalance'), namespace_, eol_))
        if self.rate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srate>%s</%srate>%s' % (namespace_, self.gds_format_double(self.rate, input_name='rate'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'period':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'period')
            self.period = ival_
        elif nodeName_ == 'beginningBalance':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'beginningBalance')
            self.beginningBalance = ival_
        elif nodeName_ == 'payment':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'payment')
            self.payment = ival_
        elif nodeName_ == 'principal':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'principal')
            self.principal = ival_
        elif nodeName_ == 'interest':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'interest')
            self.interest = ival_
        elif nodeName_ == 'endingBalance':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'endingBalance')
            self.endingBalance = ival_
        elif nodeName_ == 'rate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'rate')
            self.rate = fval_
# end class PaymentType3


class PaymentType4(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, period=None, beginningBalance=None, payment=None, principal=None, interest=None, endingBalance=None):
        self.original_tagname_ = None
        self.period = period
        self.beginningBalance = beginningBalance
        self.payment = payment
        self.principal = principal
        self.interest = interest
        self.endingBalance = endingBalance
    def factory(*args_, **kwargs_):
        if PaymentType4.subclass:
            return PaymentType4.subclass(*args_, **kwargs_)
        else:
            return PaymentType4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_period(self): return self.period
    def set_period(self, period): self.period = period
    def get_beginningBalance(self): return self.beginningBalance
    def set_beginningBalance(self, beginningBalance): self.beginningBalance = beginningBalance
    def get_payment(self): return self.payment
    def set_payment(self, payment): self.payment = payment
    def get_principal(self): return self.principal
    def set_principal(self, principal): self.principal = principal
    def get_interest(self): return self.interest
    def set_interest(self, interest): self.interest = interest
    def get_endingBalance(self): return self.endingBalance
    def set_endingBalance(self, endingBalance): self.endingBalance = endingBalance
    def hasContent_(self):
        if (
            self.period is not None or
            self.beginningBalance is not None or
            self.payment is not None or
            self.principal is not None or
            self.interest is not None or
            self.endingBalance is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='PaymentType4', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentType4')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='PaymentType4', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='PaymentType4'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='PaymentType4', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.period is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%speriod>%s</%speriod>%s' % (namespace_, self.gds_format_integer(self.period, input_name='period'), namespace_, eol_))
        if self.beginningBalance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbeginningBalance>%s</%sbeginningBalance>%s' % (namespace_, self.gds_format_integer(self.beginningBalance, input_name='beginningBalance'), namespace_, eol_))
        if self.payment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spayment>%s</%spayment>%s' % (namespace_, self.gds_format_integer(self.payment, input_name='payment'), namespace_, eol_))
        if self.principal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprincipal>%s</%sprincipal>%s' % (namespace_, self.gds_format_integer(self.principal, input_name='principal'), namespace_, eol_))
        if self.interest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinterest>%s</%sinterest>%s' % (namespace_, self.gds_format_integer(self.interest, input_name='interest'), namespace_, eol_))
        if self.endingBalance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sendingBalance>%s</%sendingBalance>%s' % (namespace_, self.gds_format_integer(self.endingBalance, input_name='endingBalance'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'period':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'period')
            self.period = ival_
        elif nodeName_ == 'beginningBalance':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'beginningBalance')
            self.beginningBalance = ival_
        elif nodeName_ == 'payment':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'payment')
            self.payment = ival_
        elif nodeName_ == 'principal':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'principal')
            self.principal = ival_
        elif nodeName_ == 'interest':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'interest')
            self.interest = ival_
        elif nodeName_ == 'endingBalance':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'endingBalance')
            self.endingBalance = ival_
# end class PaymentType4


class PaymentType5(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, period=None, beginningBalance=None, payment=None, principal=None, interest=None, endingBalance=None):
        self.original_tagname_ = None
        self.period = period
        self.beginningBalance = beginningBalance
        self.payment = payment
        self.principal = principal
        self.interest = interest
        self.endingBalance = endingBalance
    def factory(*args_, **kwargs_):
        if PaymentType5.subclass:
            return PaymentType5.subclass(*args_, **kwargs_)
        else:
            return PaymentType5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_period(self): return self.period
    def set_period(self, period): self.period = period
    def get_beginningBalance(self): return self.beginningBalance
    def set_beginningBalance(self, beginningBalance): self.beginningBalance = beginningBalance
    def get_payment(self): return self.payment
    def set_payment(self, payment): self.payment = payment
    def get_principal(self): return self.principal
    def set_principal(self, principal): self.principal = principal
    def get_interest(self): return self.interest
    def set_interest(self, interest): self.interest = interest
    def get_endingBalance(self): return self.endingBalance
    def set_endingBalance(self, endingBalance): self.endingBalance = endingBalance
    def hasContent_(self):
        if (
            self.period is not None or
            self.beginningBalance is not None or
            self.payment is not None or
            self.principal is not None or
            self.interest is not None or
            self.endingBalance is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='PaymentType5', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentType5')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='PaymentType5', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='PaymentType5'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='PaymentType5', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.period is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%speriod>%s</%speriod>%s' % (namespace_, self.gds_format_integer(self.period, input_name='period'), namespace_, eol_))
        if self.beginningBalance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbeginningBalance>%s</%sbeginningBalance>%s' % (namespace_, self.gds_format_integer(self.beginningBalance, input_name='beginningBalance'), namespace_, eol_))
        if self.payment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spayment>%s</%spayment>%s' % (namespace_, self.gds_format_integer(self.payment, input_name='payment'), namespace_, eol_))
        if self.principal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprincipal>%s</%sprincipal>%s' % (namespace_, self.gds_format_integer(self.principal, input_name='principal'), namespace_, eol_))
        if self.interest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinterest>%s</%sinterest>%s' % (namespace_, self.gds_format_integer(self.interest, input_name='interest'), namespace_, eol_))
        if self.endingBalance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sendingBalance>%s</%sendingBalance>%s' % (namespace_, self.gds_format_integer(self.endingBalance, input_name='endingBalance'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'period':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'period')
            self.period = ival_
        elif nodeName_ == 'beginningBalance':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'beginningBalance')
            self.beginningBalance = ival_
        elif nodeName_ == 'payment':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'payment')
            self.payment = ival_
        elif nodeName_ == 'principal':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'principal')
            self.principal = ival_
        elif nodeName_ == 'interest':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'interest')
            self.interest = ival_
        elif nodeName_ == 'endingBalance':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'endingBalance')
            self.endingBalance = ival_
# end class PaymentType5


class PaymentType6(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, period=None, beginningBalance=None, payment=None, interest=None, endingBalance=None, taxSavings=None):
        self.original_tagname_ = None
        self.period = period
        self.beginningBalance = beginningBalance
        self.payment = payment
        self.interest = interest
        self.endingBalance = endingBalance
        self.taxSavings = taxSavings
    def factory(*args_, **kwargs_):
        if PaymentType6.subclass:
            return PaymentType6.subclass(*args_, **kwargs_)
        else:
            return PaymentType6(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_period(self): return self.period
    def set_period(self, period): self.period = period
    def get_beginningBalance(self): return self.beginningBalance
    def set_beginningBalance(self, beginningBalance): self.beginningBalance = beginningBalance
    def get_payment(self): return self.payment
    def set_payment(self, payment): self.payment = payment
    def get_interest(self): return self.interest
    def set_interest(self, interest): self.interest = interest
    def get_endingBalance(self): return self.endingBalance
    def set_endingBalance(self, endingBalance): self.endingBalance = endingBalance
    def get_taxSavings(self): return self.taxSavings
    def set_taxSavings(self, taxSavings): self.taxSavings = taxSavings
    def hasContent_(self):
        if (
            self.period is not None or
            self.beginningBalance is not None or
            self.payment is not None or
            self.interest is not None or
            self.endingBalance is not None or
            self.taxSavings is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='PaymentType6', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentType6')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='PaymentType6', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='PaymentType6'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='PaymentType6', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.period is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%speriod>%s</%speriod>%s' % (namespace_, self.gds_format_integer(self.period, input_name='period'), namespace_, eol_))
        if self.beginningBalance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbeginningBalance>%s</%sbeginningBalance>%s' % (namespace_, self.gds_format_integer(self.beginningBalance, input_name='beginningBalance'), namespace_, eol_))
        if self.payment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spayment>%s</%spayment>%s' % (namespace_, self.gds_format_integer(self.payment, input_name='payment'), namespace_, eol_))
        if self.interest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinterest>%s</%sinterest>%s' % (namespace_, self.gds_format_integer(self.interest, input_name='interest'), namespace_, eol_))
        if self.endingBalance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sendingBalance>%s</%sendingBalance>%s' % (namespace_, self.gds_format_integer(self.endingBalance, input_name='endingBalance'), namespace_, eol_))
        if self.taxSavings is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%staxSavings>%s</%staxSavings>%s' % (namespace_, self.gds_format_integer(self.taxSavings, input_name='taxSavings'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'period':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'period')
            self.period = ival_
        elif nodeName_ == 'beginningBalance':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'beginningBalance')
            self.beginningBalance = ival_
        elif nodeName_ == 'payment':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'payment')
            self.payment = ival_
        elif nodeName_ == 'interest':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'interest')
            self.interest = ival_
        elif nodeName_ == 'endingBalance':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'endingBalance')
            self.endingBalance = ival_
        elif nodeName_ == 'taxSavings':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'taxSavings')
            self.taxSavings = ival_
# end class PaymentType6


class PaymentType7(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, period=None, beginningBalance=None, payment=None, interest=None, endingBalance=None):
        self.original_tagname_ = None
        self.period = period
        self.beginningBalance = beginningBalance
        self.payment = payment
        self.interest = interest
        self.endingBalance = endingBalance
    def factory(*args_, **kwargs_):
        if PaymentType7.subclass:
            return PaymentType7.subclass(*args_, **kwargs_)
        else:
            return PaymentType7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_period(self): return self.period
    def set_period(self, period): self.period = period
    def get_beginningBalance(self): return self.beginningBalance
    def set_beginningBalance(self, beginningBalance): self.beginningBalance = beginningBalance
    def get_payment(self): return self.payment
    def set_payment(self, payment): self.payment = payment
    def get_interest(self): return self.interest
    def set_interest(self, interest): self.interest = interest
    def get_endingBalance(self): return self.endingBalance
    def set_endingBalance(self, endingBalance): self.endingBalance = endingBalance
    def hasContent_(self):
        if (
            self.period is not None or
            self.beginningBalance is not None or
            self.payment is not None or
            self.interest is not None or
            self.endingBalance is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='PaymentType7', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentType7')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='PaymentType7', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='PaymentType7'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='PaymentType7', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.period is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%speriod>%s</%speriod>%s' % (namespace_, self.gds_format_integer(self.period, input_name='period'), namespace_, eol_))
        if self.beginningBalance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbeginningBalance>%s</%sbeginningBalance>%s' % (namespace_, self.gds_format_integer(self.beginningBalance, input_name='beginningBalance'), namespace_, eol_))
        if self.payment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spayment>%s</%spayment>%s' % (namespace_, self.gds_format_integer(self.payment, input_name='payment'), namespace_, eol_))
        if self.interest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinterest>%s</%sinterest>%s' % (namespace_, self.gds_format_integer(self.interest, input_name='interest'), namespace_, eol_))
        if self.endingBalance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sendingBalance>%s</%sendingBalance>%s' % (namespace_, self.gds_format_integer(self.endingBalance, input_name='endingBalance'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'period':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'period')
            self.period = ival_
        elif nodeName_ == 'beginningBalance':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'beginningBalance')
            self.beginningBalance = ival_
        elif nodeName_ == 'payment':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'payment')
            self.payment = ival_
        elif nodeName_ == 'interest':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'interest')
            self.interest = ival_
        elif nodeName_ == 'endingBalance':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'endingBalance')
            self.endingBalance = ival_
# end class PaymentType7


class PaymentType8(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, period=None, beginningBalance=None, payment=None, interest=None, endingBalance=None):
        self.original_tagname_ = None
        self.period = period
        self.beginningBalance = beginningBalance
        self.payment = payment
        self.interest = interest
        self.endingBalance = endingBalance
    def factory(*args_, **kwargs_):
        if PaymentType8.subclass:
            return PaymentType8.subclass(*args_, **kwargs_)
        else:
            return PaymentType8(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_period(self): return self.period
    def set_period(self, period): self.period = period
    def get_beginningBalance(self): return self.beginningBalance
    def set_beginningBalance(self, beginningBalance): self.beginningBalance = beginningBalance
    def get_payment(self): return self.payment
    def set_payment(self, payment): self.payment = payment
    def get_interest(self): return self.interest
    def set_interest(self, interest): self.interest = interest
    def get_endingBalance(self): return self.endingBalance
    def set_endingBalance(self, endingBalance): self.endingBalance = endingBalance
    def hasContent_(self):
        if (
            self.period is not None or
            self.beginningBalance is not None or
            self.payment is not None or
            self.interest is not None or
            self.endingBalance is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='PaymentType8', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PaymentType8')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='PaymentType8', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='PaymentType8'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='PaymentType8', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.period is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%speriod>%s</%speriod>%s' % (namespace_, self.gds_format_integer(self.period, input_name='period'), namespace_, eol_))
        if self.beginningBalance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbeginningBalance>%s</%sbeginningBalance>%s' % (namespace_, self.gds_format_integer(self.beginningBalance, input_name='beginningBalance'), namespace_, eol_))
        if self.payment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spayment>%s</%spayment>%s' % (namespace_, self.gds_format_integer(self.payment, input_name='payment'), namespace_, eol_))
        if self.interest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinterest>%s</%sinterest>%s' % (namespace_, self.gds_format_integer(self.interest, input_name='interest'), namespace_, eol_))
        if self.endingBalance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sendingBalance>%s</%sendingBalance>%s' % (namespace_, self.gds_format_integer(self.endingBalance, input_name='endingBalance'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'period':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'period')
            self.period = ival_
        elif nodeName_ == 'beginningBalance':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'beginningBalance')
            self.beginningBalance = ival_
        elif nodeName_ == 'payment':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'payment')
            self.payment = ival_
        elif nodeName_ == 'interest':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'interest')
            self.interest = ival_
        elif nodeName_ == 'endingBalance':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'endingBalance')
            self.endingBalance = ival_
# end class PaymentType8


class pairsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ltv=None, loanAmount=None):
        self.original_tagname_ = None
        self.ltv = ltv
        self.loanAmount = loanAmount
    def factory(*args_, **kwargs_):
        if pairsType.subclass:
            return pairsType.subclass(*args_, **kwargs_)
        else:
            return pairsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ltv(self): return self.ltv
    def set_ltv(self, ltv): self.ltv = ltv
    def get_loanAmount(self): return self.loanAmount
    def set_loanAmount(self, loanAmount): self.loanAmount = loanAmount
    def hasContent_(self):
        if (
            self.ltv is not None or
            self.loanAmount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='pairsType', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pairsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='pairsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='pairsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='pairsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ltv is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sltv>%s</%sltv>%s' % (namespace_, self.gds_format_double(self.ltv, input_name='ltv'), namespace_, eol_))
        if self.loanAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sloanAmount>%s</%sloanAmount>%s' % (namespace_, self.gds_format_integer(self.loanAmount, input_name='loanAmount'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ltv':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ltv')
            self.ltv = fval_
        elif nodeName_ == 'loanAmount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'loanAmount')
            self.loanAmount = ival_
# end class pairsType


class buyingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, mortgagePayment=None, principal=None, interest=None, hoaFees=None, propertyTaxes=None, utilities=None, renovations=None, maintainCosts=None, homeOwnerInsurance=None, opportunityCostInitial=None, opportunityCostYearly=None, totalBenefit=None, totalCost=None):
        self.original_tagname_ = None
        self.mortgagePayment = mortgagePayment
        self.principal = principal
        self.interest = interest
        self.hoaFees = hoaFees
        self.propertyTaxes = propertyTaxes
        self.utilities = utilities
        self.renovations = renovations
        self.maintainCosts = maintainCosts
        self.homeOwnerInsurance = homeOwnerInsurance
        self.opportunityCostInitial = opportunityCostInitial
        self.opportunityCostYearly = opportunityCostYearly
        self.totalBenefit = totalBenefit
        self.totalCost = totalCost
    def factory(*args_, **kwargs_):
        if buyingType.subclass:
            return buyingType.subclass(*args_, **kwargs_)
        else:
            return buyingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mortgagePayment(self): return self.mortgagePayment
    def set_mortgagePayment(self, mortgagePayment): self.mortgagePayment = mortgagePayment
    def get_principal(self): return self.principal
    def set_principal(self, principal): self.principal = principal
    def get_interest(self): return self.interest
    def set_interest(self, interest): self.interest = interest
    def get_hoaFees(self): return self.hoaFees
    def set_hoaFees(self, hoaFees): self.hoaFees = hoaFees
    def get_propertyTaxes(self): return self.propertyTaxes
    def set_propertyTaxes(self, propertyTaxes): self.propertyTaxes = propertyTaxes
    def get_utilities(self): return self.utilities
    def set_utilities(self, utilities): self.utilities = utilities
    def get_renovations(self): return self.renovations
    def set_renovations(self, renovations): self.renovations = renovations
    def get_maintainCosts(self): return self.maintainCosts
    def set_maintainCosts(self, maintainCosts): self.maintainCosts = maintainCosts
    def get_homeOwnerInsurance(self): return self.homeOwnerInsurance
    def set_homeOwnerInsurance(self, homeOwnerInsurance): self.homeOwnerInsurance = homeOwnerInsurance
    def get_opportunityCostInitial(self): return self.opportunityCostInitial
    def set_opportunityCostInitial(self, opportunityCostInitial): self.opportunityCostInitial = opportunityCostInitial
    def get_opportunityCostYearly(self): return self.opportunityCostYearly
    def set_opportunityCostYearly(self, opportunityCostYearly): self.opportunityCostYearly = opportunityCostYearly
    def get_totalBenefit(self): return self.totalBenefit
    def set_totalBenefit(self, totalBenefit): self.totalBenefit = totalBenefit
    def get_totalCost(self): return self.totalCost
    def set_totalCost(self, totalCost): self.totalCost = totalCost
    def hasContent_(self):
        if (
            self.mortgagePayment is not None or
            self.principal is not None or
            self.interest is not None or
            self.hoaFees is not None or
            self.propertyTaxes is not None or
            self.utilities is not None or
            self.renovations is not None or
            self.maintainCosts is not None or
            self.homeOwnerInsurance is not None or
            self.opportunityCostInitial is not None or
            self.opportunityCostYearly is not None or
            self.totalBenefit is not None or
            self.totalCost is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='buyingType', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='buyingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='buyingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='buyingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='buyingType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mortgagePayment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smortgagePayment>%s</%smortgagePayment>%s' % (namespace_, self.gds_format_integer(self.mortgagePayment, input_name='mortgagePayment'), namespace_, eol_))
        if self.principal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprincipal>%s</%sprincipal>%s' % (namespace_, self.gds_format_integer(self.principal, input_name='principal'), namespace_, eol_))
        if self.interest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinterest>%s</%sinterest>%s' % (namespace_, self.gds_format_integer(self.interest, input_name='interest'), namespace_, eol_))
        if self.hoaFees is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shoaFees>%s</%shoaFees>%s' % (namespace_, self.gds_format_integer(self.hoaFees, input_name='hoaFees'), namespace_, eol_))
        if self.propertyTaxes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spropertyTaxes>%s</%spropertyTaxes>%s' % (namespace_, self.gds_format_integer(self.propertyTaxes, input_name='propertyTaxes'), namespace_, eol_))
        if self.utilities is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sutilities>%s</%sutilities>%s' % (namespace_, self.gds_format_integer(self.utilities, input_name='utilities'), namespace_, eol_))
        if self.renovations is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srenovations>%s</%srenovations>%s' % (namespace_, self.gds_format_integer(self.renovations, input_name='renovations'), namespace_, eol_))
        if self.maintainCosts is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaintainCosts>%s</%smaintainCosts>%s' % (namespace_, self.gds_format_integer(self.maintainCosts, input_name='maintainCosts'), namespace_, eol_))
        if self.homeOwnerInsurance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shomeOwnerInsurance>%s</%shomeOwnerInsurance>%s' % (namespace_, self.gds_format_integer(self.homeOwnerInsurance, input_name='homeOwnerInsurance'), namespace_, eol_))
        if self.opportunityCostInitial is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sopportunityCostInitial>%s</%sopportunityCostInitial>%s' % (namespace_, self.gds_format_integer(self.opportunityCostInitial, input_name='opportunityCostInitial'), namespace_, eol_))
        if self.opportunityCostYearly is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sopportunityCostYearly>%s</%sopportunityCostYearly>%s' % (namespace_, self.gds_format_integer(self.opportunityCostYearly, input_name='opportunityCostYearly'), namespace_, eol_))
        if self.totalBenefit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalBenefit>%s</%stotalBenefit>%s' % (namespace_, self.gds_format_integer(self.totalBenefit, input_name='totalBenefit'), namespace_, eol_))
        if self.totalCost is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalCost>%s</%stotalCost>%s' % (namespace_, self.gds_format_integer(self.totalCost, input_name='totalCost'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mortgagePayment':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'mortgagePayment')
            self.mortgagePayment = ival_
        elif nodeName_ == 'principal':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'principal')
            self.principal = ival_
        elif nodeName_ == 'interest':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'interest')
            self.interest = ival_
        elif nodeName_ == 'hoaFees':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'hoaFees')
            self.hoaFees = ival_
        elif nodeName_ == 'propertyTaxes':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'propertyTaxes')
            self.propertyTaxes = ival_
        elif nodeName_ == 'utilities':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'utilities')
            self.utilities = ival_
        elif nodeName_ == 'renovations':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'renovations')
            self.renovations = ival_
        elif nodeName_ == 'maintainCosts':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'maintainCosts')
            self.maintainCosts = ival_
        elif nodeName_ == 'homeOwnerInsurance':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'homeOwnerInsurance')
            self.homeOwnerInsurance = ival_
        elif nodeName_ == 'opportunityCostInitial':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'opportunityCostInitial')
            self.opportunityCostInitial = ival_
        elif nodeName_ == 'opportunityCostYearly':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'opportunityCostYearly')
            self.opportunityCostYearly = ival_
        elif nodeName_ == 'totalBenefit':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'totalBenefit')
            self.totalBenefit = ival_
        elif nodeName_ == 'totalCost':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'totalCost')
            self.totalCost = ival_
# end class buyingType


class rentingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, rent=None, rentersInsurance=None, opportunityCostInitial=None, opportunityCostYearly=None, totalCost=None):
        self.original_tagname_ = None
        self.rent = rent
        self.rentersInsurance = rentersInsurance
        self.opportunityCostInitial = opportunityCostInitial
        self.opportunityCostYearly = opportunityCostYearly
        self.totalCost = totalCost
    def factory(*args_, **kwargs_):
        if rentingType.subclass:
            return rentingType.subclass(*args_, **kwargs_)
        else:
            return rentingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rent(self): return self.rent
    def set_rent(self, rent): self.rent = rent
    def get_rentersInsurance(self): return self.rentersInsurance
    def set_rentersInsurance(self, rentersInsurance): self.rentersInsurance = rentersInsurance
    def get_opportunityCostInitial(self): return self.opportunityCostInitial
    def set_opportunityCostInitial(self, opportunityCostInitial): self.opportunityCostInitial = opportunityCostInitial
    def get_opportunityCostYearly(self): return self.opportunityCostYearly
    def set_opportunityCostYearly(self, opportunityCostYearly): self.opportunityCostYearly = opportunityCostYearly
    def get_totalCost(self): return self.totalCost
    def set_totalCost(self, totalCost): self.totalCost = totalCost
    def hasContent_(self):
        if (
            self.rent is not None or
            self.rentersInsurance is not None or
            self.opportunityCostInitial is not None or
            self.opportunityCostYearly is not None or
            self.totalCost is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='rentingType', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='rentingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='rentingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='rentingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='rentingType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.rent is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srent>%s</%srent>%s' % (namespace_, self.gds_format_integer(self.rent, input_name='rent'), namespace_, eol_))
        if self.rentersInsurance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srentersInsurance>%s</%srentersInsurance>%s' % (namespace_, self.gds_format_integer(self.rentersInsurance, input_name='rentersInsurance'), namespace_, eol_))
        if self.opportunityCostInitial is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sopportunityCostInitial>%s</%sopportunityCostInitial>%s' % (namespace_, self.gds_format_integer(self.opportunityCostInitial, input_name='opportunityCostInitial'), namespace_, eol_))
        if self.opportunityCostYearly is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sopportunityCostYearly>%s</%sopportunityCostYearly>%s' % (namespace_, self.gds_format_integer(self.opportunityCostYearly, input_name='opportunityCostYearly'), namespace_, eol_))
        if self.totalCost is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalCost>%s</%stotalCost>%s' % (namespace_, self.gds_format_integer(self.totalCost, input_name='totalCost'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rent':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'rent')
            self.rent = ival_
        elif nodeName_ == 'rentersInsurance':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'rentersInsurance')
            self.rentersInsurance = ival_
        elif nodeName_ == 'opportunityCostInitial':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'opportunityCostInitial')
            self.opportunityCostInitial = ival_
        elif nodeName_ == 'opportunityCostYearly':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'opportunityCostYearly')
            self.opportunityCostYearly = ival_
        elif nodeName_ == 'totalCost':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'totalCost')
            self.totalCost = ival_
# end class rentingType


class sellingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sellingCosts=None, remainingPrincipal=None, homeValue=None, tax=None):
        self.original_tagname_ = None
        self.sellingCosts = sellingCosts
        self.remainingPrincipal = remainingPrincipal
        self.homeValue = homeValue
        self.tax = tax
    def factory(*args_, **kwargs_):
        if sellingType.subclass:
            return sellingType.subclass(*args_, **kwargs_)
        else:
            return sellingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sellingCosts(self): return self.sellingCosts
    def set_sellingCosts(self, sellingCosts): self.sellingCosts = sellingCosts
    def get_remainingPrincipal(self): return self.remainingPrincipal
    def set_remainingPrincipal(self, remainingPrincipal): self.remainingPrincipal = remainingPrincipal
    def get_homeValue(self): return self.homeValue
    def set_homeValue(self, homeValue): self.homeValue = homeValue
    def get_tax(self): return self.tax
    def set_tax(self, tax): self.tax = tax
    def hasContent_(self):
        if (
            self.sellingCosts is not None or
            self.remainingPrincipal is not None or
            self.homeValue is not None or
            self.tax is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ZillowTypes:', name_='sellingType', namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sellingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ZillowTypes:', name_='sellingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ZillowTypes:', name_='sellingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ZillowTypes:', name_='sellingType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.sellingCosts is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssellingCosts>%s</%ssellingCosts>%s' % (namespace_, self.gds_format_integer(self.sellingCosts, input_name='sellingCosts'), namespace_, eol_))
        if self.remainingPrincipal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sremainingPrincipal>%s</%sremainingPrincipal>%s' % (namespace_, self.gds_format_integer(self.remainingPrincipal, input_name='remainingPrincipal'), namespace_, eol_))
        if self.homeValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shomeValue>%s</%shomeValue>%s' % (namespace_, self.gds_format_integer(self.homeValue, input_name='homeValue'), namespace_, eol_))
        if self.tax is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stax>%s</%stax>%s' % (namespace_, self.gds_format_integer(self.tax, input_name='tax'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'sellingCosts':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'sellingCosts')
            self.sellingCosts = ival_
        elif nodeName_ == 'remainingPrincipal':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'remainingPrincipal')
            self.remainingPrincipal = ival_
        elif nodeName_ == 'homeValue':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'homeValue')
            self.homeValue = ival_
        elif nodeName_ == 'tax':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'tax')
            self.tax = ival_
# end class sellingType


GDSClassesMapping = {
    'renting': rentingType,
    'ad': TerseAddress,
    'links': linksType,
    'zestimate': SimpleZestimate,
    'high': Amount,
    'rate': MortgageInterestRate,
    'lastSoldPrice': Amount,
    'biWeeklyAmortizationSchedule': BiWeeklyPaymentAmortizationSchedule2,
    'InvestmentYearlyCostsTable': investmentYearlyCostsTable,
    'rentzestimate': Zestimate,
    'InterestOnlyAmortizationSchedule': annualInterestOnlyAmortizationSchedule,
    'amount': Amount,
    'oneWeekChange': AmountOptional,
    'regions': Regions,
    'AmortizationSchedule': annualAmortizationSchedule,
    'Payment': PaymentType8,
    'today': MortgageRateList,
    'low': Amount,
    'selling': sellingType,
    'myzestimator': DeprecatedType,
    'lastWeek': MortgageRateList,
    'valueChange': AmountOptional,
    'InvestmentcumulativeYearlyCostsTable': investmentCumulativeYearlyCostsTable,
    'address': RestrictedAddress,
    'payment': paymentType2,
    'buying': buyingType,
    'pairs': pairsType,
    'region': regionType,
    'valuationRange': valuationRangeType1,
    'localRealEstate': LocalRealEstate,
    'savingsTableSchedule': SavingsTableSchedule,
    'amortizationSchedule': TaxSavingsAmortizationSchedule,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Amount'
        rootClass = Amount
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Amount'
        rootClass = Amount
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    parser = None
    doc = parsexml_(StringIO(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Amount'
        rootClass = Amount
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:ZillowTypes="http://www.zillow.com/static/xsd/ZillowTypes.xsd"')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Amount'
        rootClass = Amount
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from zillow_types import *\n\n')
        sys.stdout.write('import zillow_types as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "Address",
    "AdjustableMortgage",
    "AdjustableMortgageAmortizationSchedule",
    "AmortizationSchedule",
    "Amount",
    "AmountOptional",
    "BiWeeklyPayment",
    "BiWeeklyPaymentAmortizationSchedule",
    "BiWeeklyPaymentAmortizationSchedule2",
    "ComparableProperty",
    "DeprecatedType",
    "DetailedProperty",
    "DiscountPoints",
    "FMRProperty",
    "FixedVsAdjustableRate",
    "FixedVsAdjustableRateAmortizationSchedule",
    "Heloc",
    "InterstOnlyVsTraditional",
    "Investment",
    "LenderAccountStatus",
    "Links",
    "LocalRealEstate",
    "Message",
    "MonthlyPaymentData",
    "MonthlyPaymentsDetails",
    "MonthlyPaymentsSummary",
    "MortgageInterestRate",
    "MortgageRateList",
    "MortgageRateSummary",
    "MortgageTerms",
    "NoCostVsTraditional",
    "PaymentType",
    "PaymentType3",
    "PaymentType4",
    "PaymentType5",
    "PaymentType6",
    "PaymentType7",
    "PaymentType8",
    "Property",
    "ReallySimpleProperty",
    "Refinance",
    "RegionNames",
    "Regions",
    "RentVsBuy",
    "RestrictedAddress",
    "SavingsTableSchedule",
    "SimpleProperty",
    "SimpleZestimate",
    "TaxSavings",
    "TaxSavingsAmortizationSchedule",
    "TerseAddress",
    "Zestimate",
    "annualAmortizationSchedule",
    "annualInterestOnlyAmortizationSchedule",
    "buying",
    "buyingBlock",
    "buyingType",
    "cumulativeYearlyCostsTable",
    "investmentBuyingBlock",
    "investmentCumulativeYearlyCostsTable",
    "investmentYearlyCostsTable",
    "linksType",
    "loanAmountPairs",
    "pairsType",
    "paymentType",
    "paymentType2",
    "regionType",
    "rentingBlock",
    "rentingType",
    "sellingBlock",
    "sellingType",
    "valuationRangeType",
    "valuationRangeType1",
    "yearlyCostsTable"
]
